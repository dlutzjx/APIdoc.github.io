<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
	<head>
		<title>Repository of Publications on API Documentation Analysis</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<link href="bootstrap.min.css" rel="stylesheet">

<link href="custom.css" rel="stylesheet">
<link href="syntax.css" rel="stylesheet">

<!--[if lt IE 9]><script src="../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->


<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  <style type="text/css"></style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-9372397-3', 'auto');
  ga('send', 'pageview');

</script>
		<script type="text/javascript">

				if (window.addEventListener) {
					window.addEventListener("load",initSearch,false); }
				else if (window.attachEvent) {
					window.attachEvent("onload", initSearch); }
				
				function initSearch() {
					searchTable = document.getElementById('qstable');
				}

				function toggleInfo(articleid,info) {
					var entry = document.getElementById(articleid);
					var abs = document.getElementById('abs_'+articleid);
					var rev = document.getElementById('rev_'+articleid);
					var bib = document.getElementById('bib_'+articleid);
					
					// Get the abstracts/reviews/bibtext in the right location
					// in unsorted tables this is always the case, but in sorted tables it is necessary. 
					// Start moving in reverse order, so we get: entry, abstract,review,bibtex
					if (searchTable.className.indexOf('sortable') != -1) {
						if(bib) { entry.parentNode.insertBefore(bib,entry.nextSibling); }
						if(rev) { entry.parentNode.insertBefore(rev,entry.nextSibling); }
						if(abs) { entry.parentNode.insertBefore(abs,entry.nextSibling); }
					}
				
					if (abs && info == 'abstract') {
						if(abs.className.indexOf('abstract') != -1) {
						abs.className.indexOf('noshow') == -1?abs.className = 'abstract noshow':abs.className = 'abstract';
						}
					} else if (rev && info == 'review') {
						if(rev.className.indexOf('review') != -1) {
						rev.className.indexOf('noshow') == -1?rev.className = 'review noshow':rev.className = 'review';
						}
					} else if (bib && info == 'bibtex') {
						if(bib.className.indexOf('bibtex') != -1) {
						bib.className.indexOf('noshow') == -1?bib.className = 'bibtex noshow':bib.className = 'bibtex';
						}		
					} else { 
						return;
					}
				
					// check if one or the other is available
					var revshow = false;
					var absshow = false;
					var bibshow = false;
					(abs && abs.className.indexOf('noshow') == -1)? absshow = true: absshow = false;
					(rev && rev.className.indexOf('noshow') == -1)? revshow = true: revshow = false;	
					(bib && bib.className == 'bibtex')? bibshow = true: bibshow = false;
					
					// highlight original entry
					if(entry) {
						if (revshow || absshow || bibshow) {
						entry.className = 'entry highlight show';
						} else {
						entry.className = 'entry show';
						}		
					}
					
					// When there's a combination of abstract/review/bibtex showing, need to add class for correct styling
					if(absshow) {
						(revshow||bibshow)?abs.className = 'abstract nextshow':abs.className = 'abstract';
					} 
					if (revshow) {
						bibshow?rev.className = 'review nextshow': rev.className = 'review';
					}
					
				}
				
	
		</script>
		

		<style type="text/css">
			body { background-color: white; font-family: "Arial", Arial, sans-serif; font-size: 15px; line-height: 1.2; padding: 1em; color: #2E2E2E; }
			
			
			.invalidsearch { background-color: red; }
			
			table { border: 0px gray solid; width: 100%; empty-cells: show; }
			th, td { border: 0px gray solid; padding: 0.5em; vertical-align: top;  }
			td { text-align: left; vertical-align: top; }
			th { background-color: #EFEFEF; }
			
			td a { color: navy; text-decoration: none; }
			td a:hover  { text-decoration: underline; }
			
			tr.noshow { display: none;}
			
			tr.highlight td { background-color: #F1F1F1; border-top: 0px black solid; font-weight: bold; }
			tr.abstract td, tr.review td, tr.bibtex td { background-color: #F1F1F1; border-bottom: 0px black solid; }
			tr.nextshow td { border-bottom: 0px gray solid; }
			
			tr.bibtex pre { width: 100%; overflow: auto;}
			
			p.infolinks { margin: 0.5em 0em 0em 0em; padding: 0px; }
			
			
			@media print {
				p.infolinks, #qssettings, #qs { display: none !important; }
				table { border-width: 0px; }
				tr { page-break-inside: avoid; }
				th input, th select { display: none; }
			}
	</style>
</head>
	<body data-twttr-rendered="true">
      <header class="navbar navbar-static-top bs-docs-nav custom_navbar navbar-fixed-top" id="top" role="banner">
    <div class="color_wrapper"></div>
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://oscar-lab.org">OSCAR</a></li>
        <li><a href="http://oscar-lab.org/people/~jxzhang/index.htm">MyPage</a></li>
      </ul>
    </nav>
  </div>
</header>
<div class="nav-space"></div>
  <div class="page-titile-wraper aboutme-wraper">
  <div class="container">
  </div>
</div>
	
	<div class="container">
	<div class="row">
		<div class="col-md-12" role="main">
			<h2 class="page-header">Repository of Publications on API Documentation Analysis</h2>
			
			<div class="row" style="text-align:justify; text-justify:inter-ideograph;>
				<div class="col-md-12" class="justify">
					      
				<p>This page collects the papers that analyze API documentation.
			<p>This page is maintained by <a href="http://oscar-lab.org/people/~jxzhang/index.htm">Jingxuan Zhang</a> and <a href="http://faculty.dlut.edu.cn/jianghe/en/index.htm">He Jiang</a> from School of Software, Dalian University of Technology, China. 	
			<p>The works ananlyzing API documentaion can be roughly divided into ten categories: 										    
			<br><br>
				
		<h4><b>(1) <u>API Usage Patterns Identification:</u></b></h4>
		<br>
		
		 <ol class="paper-list" id="grants">
		
		
			
			
			
			
			
			
			<table id="qstable" class="sortable" border="0">
<tr id="Huppe2017Mining" class="entry">
<li>S. Huppe, M. A. Saied, and H. Sahraoui, "Mining complex temporal api usage patterns: An evolutionary approach," in IEEE/ACM International Conference on Software Engineering Companion, 2017, pp. 274-276.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Huppe2017Mining','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Huppe2017Mining','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Huppe2017Mining" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Learning to use existing or new software libraries is a difficult task for software developers, which would impede their productivity. Much existing work has provided different techniques to mine API usage patterns from client programs inorder to help developers on understanding and using existinglibraries. However, these techniques produce incomplete patterns, i.e., without temporal properties, or simple ones. In this paper, we propose a new formulation of the problem of API temporal pattern mining and a new approach to solve it. Indeed, we learn complex temporal patterns using a genetic programming approach. Our preliminary results show that across a considerable variability of client programs, our approach has been able to infer non-trivial patterns that reflect informative temporal properties. </td></tr>
<tr id="bib_Huppe2017Mining" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Huppe2017Mining,
  title={Mining Complex Temporal API Usage Patterns: An Evolutionary Approach},
  author={Huppe, Samuel and Saied, Mohamed Aymen and Sahraoui, Houari},
  booktitle={Ieee/acm  International Conference on Software Engineering Companion},
  pages={274-276},
  year={2017},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Salman2017Identification" class="entry">
<li>H. E. Salman, "Identification multi-level frequent usage patterns from apis," Journal of Systems & Software, vol. 130, pp. 42-56, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Salman2017Identification','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Salman2017Identification','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Salman2017Identification" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers increasingly rely on application programming interfaces (APIs) of frameworks to increase productivity. An API method is generally used within code snippets along with other methods of the API of interest. When developers invoke API methods in a framework, they often encounter difficulty to determine which methods to call due to the huge number of included methods in that API. Developers usually exploit a source code search tool searching for code snippets that use the API methods of interest. However, the number of returned code snippets is very large which hinders the developer to locate useful ones. Moreover, co-usage relationships between API methods are often not documented. This article presents an approach to identify multi-level frequent usage patterns (IML-FUP) to help developers understand API usage and facilitate the development tasks when they use new APIs. An identified pattern represents a set of API methods that are frequently called together across interfering usage scenarios. In order to investigate the efficiency of the proposed approach, an experimental evaluation is conducted using four APIs and 89 client programs. For all studied APIs, the experimental results show that the proposed approach identifies usage patterns that are always strongly cohesive and highly consistent. </td></tr>
<tr id="bib_Salman2017Identification" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Salman2017Identification,
  title={Identification multi-level frequent usage patterns from APIs},
  author={Salman, Hamzeh Eyal},
  journal={Journal of Systems & Software},
  volume={130},
  pages={42-56},
  year={2017},
 keywords={API documentation;API usage;Formal concept analysis;Identification;Usage patterns},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Azad2017Generating" class="entry">
<li>S. Azad, P. C. Rigby, and L. Guerrouj, "Generating api call rules from version history and stack overflow posts," Acm Transactions on Software Engineering & Methodology, vol. 25, no. 4, p. 29, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Azad2017Generating','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Azad2017Generating','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Azad2017Generating" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Researchers have shown that related functions can be mined from groupings of functions found in the version history of a system. Our first contribution is to expand this approach to a community of applications and set of similar applications. Android developers use a set of application programming interface (API) calls when creating apps. These API calls are used in similar ways across multiple applications. By clustering co-changing API calls used by 230 Android apps across 12k versions, we are able to predict the API calls that individual app developers will use with an average precision of 75% and recall of 22%. When we make predictions from the same category of app, such as Finance, we attain precision and recall of 81% and 28%, respectively. Our second contribution can be characterized as 鈥減rogrammers who discussed these functions were also interested in these functions.鈿 Informal discussions on Stack Overflow provide a rich source of information about related API calls as developers provide solutions to common problems. By grouping API calls contained in each positively voted answer posts, we are able to create rules that predict the calls that app developers will use in their own apps with an average precision of 66% and recall of 13%. For comparison purposes, we developed a baseline by clustering co-changing API calls for each individual app and generated association rules from them. The baseline predicts API calls used by app developers with a precision and recall of 36% and 23%, respectively. </td></tr>
<tr id="bib_Azad2017Generating" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Azad2017Generating,
  title={Generating API Call Rules from Version History and Stack Overflow Posts},
  author={Azad, Shams and Rigby, Peter C. and Guerrouj, Latifa},
  journal={Acm Transactions on Software Engineering & Methodology},
  volume={25},
  number={4},
  pages={29},
  year={2017},
 keywords={API method calls;Stack Overflow;association rule mining;community of applications;informal documentation;version history},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Xiong2017Precise" class="entry">
<li>Y. Xiong, J. Wang, R. Yan, J. Zhang, S. Han, G. Huang, and L. Zhang, "Precise condition synthesis for program repair," in IEEE/ACM International Conference on Software Engineering, 2017, pp. 416-426.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Xiong2017Precise','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Xiong2017Precise','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Xiong2017Precise" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Due to the difficulty of repairing defect, many research efforts have been devoted into automatic defect repair. Given a buggy program that fails some test cases, a typical automatic repair technique tries to modify the program to make all tests pass. However, since the test suites in real world projects are usually insufficient, aiming at passing the test suites often leads to incorrect patches. This problem is known as weak test suites or overfitting. In this paper we aim to produce precise patches, that is, any patch we produce has a relatively high probability to be correct. More concretely, we focus on condition synthesis, which was shown to be able to repair more than half of the defects in existing approaches. Our key insight is threefold. First, it is important to know what variables in a local context should be used in an "if" condition, and we propose a sorting method based on the dependency relations between variables. Second, we observe that the API document can be used to guide the repair process, and propose document analysis technique to further filter the variables. Third, it is important to know what predicates should be performed on the set of variables, and we propose to mine a set of frequently used predicates in similar contexts from existing projects. Based on the insight, we develop a novel program repair system, ACS, that could generate precise conditions at faulty locations. Furthermore, given the generated conditions are very precise, we can perform a repair operation that is previously deemed to be too overfitting: directly returning the test oracle to repair the defect. Using our approach, we successfully repaired 18 defects on four projects of Defects4J, which is the largest number of fully automatically repaired defects reported on the dataset so far. More importantly, the precision of our approach in the evaluation is 78.3%, which is significantly higher than previous approaches, which are usually less than 40%. </td></tr>
<tr id="bib_Xiong2017Precise" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Xiong2017Precise,
  title={Precise Condition Synthesis for Program Repair},
  author={Xiong, Yingfei and Wang, Jie and Yan, Runfa and Zhang, Jiachen and Han, Shi and Huang, Gang and Zhang, Lu},
  booktitle={Ieee/acm  International Conference on Software Engineering},
  pages={416-426},
  year={2017},
 keywords={ieee computer society},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Saied2016A" class="entry">
<li>M. A. Saied and H. Sahraoui, "A cooperative approach for combining client-based and library-based api usage pattern mining," in IEEE International Conference on Program Comprehension, 2016, pp. 1-10.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Saied2016A','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Saied2016A','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Saied2016A" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers need to cope with the complexity of Application Programming Interfaces (APIs) of external libraries or frameworks. Typical APIs provide thousands of methods to their client programs, and these methods are not used independently of each other. Much existing work has provided different techniques to mine API usage patterns based on client programs in order to help developers understanding and using existing libraries. Other techniques propose to overcome the strong constraint of clients' dependency and infer API usage patterns only using the library source code. In this paper, we propose a cooperative usage pattern mining technique (COUPminer) that combines client-based and library-based usage pattern mining. We evaluated our technique through four APIs and the obtained results show that the cooperative approach allows taking advantage at the same time from the precision of client-based technique and from the generalizability of library-based techniques. </td></tr>
<tr id="bib_Saied2016A" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Saied2016A,
  title={A cooperative approach for combining client-based and library-based API usage pattern mining},
  author={Saied, Mohamed Aymen and Sahraoui, Houari},
  booktitle={IEEE  International Conference on Program Comprehension},
  pages={1-10},
  year={2016},
 keywords={Software Clustering;API Documentation;API Usage;Usage Pattern},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Saied2015Could" class="entry">
<li>M. A. Saied, H. Abdeen, O. Benomar, and H. Sahraoui, "Could we infer unordered api usage patterns only using the library source code?" in IEEE International Conference on Program Comprehension, 2015, pp. 71-81.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Saied2015Could','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Saied2015Could','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Saied2015Could" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Learning to use existing or new software libraries is a difficult task for software developers, which would impede their productivity. Much existing work has provided different techniques to mine API usage patterns from client programs in order to help developers on understanding and using existing libraries. However, considering only client programs to identify API usage patterns is a strong constraint as the client programs source code is not always available or the clients themselves do not exist yet for newly released APIs. In this paper, we propose a technique for mining Non Client-based Usage Patterns (NCBUP miner). We detect unordered API usage patterns as distinct groups of API methods that are structurally and semantically related and thus may contribute together to the implementation of a particular functionality for potential client programs. We evaluated our technique through four APIs. The obtained results are comparable to those of client-based approaches in terms of usage-patterns cohesion. </td></tr>
<tr id="bib_Saied2015Could" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Saied2015Could,
  title={Could We Infer Unordered API Usage Patterns Only Using the Library Source Code?},
  author={Saied, Mohamed Aymen and Abdeen, Hani and Benomar, Omar and Sahraoui, Houari},
  booktitle={IEEE  International Conference on Program Comprehension},
  pages={71-81},
  year={2015},
 keywords={Software Clustering;API Documentation;API Usage;Usage Pattern},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Pandita2015Discovering" class="entry">
<li>R. Pandita, R. P. Jetley, S. D. Sudarsan, and L. Williams, "Discovering likely mappings between apis using text mining," in IEEE International Working Conference on Source Code Analysis and Manipulation, 2015, pp. 231-240.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Pandita2015Discovering','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Pandita2015Discovering','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Pandita2015Discovering" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Developers often release different versions of their applications to support various platform/programming-language application programming interfaces (APIs). To migrate an application written using one API (source) to another API (target), a developer must know how the methods in the source API map to the methods in the target API. Given a typical platform or language exposes a large number of API methods, manually writing API mappings is prohibitively resource-intensive and may be error prone. Recently, researchers proposed to automate the mapping process by mining API mappings from existing code-bases. However, these approaches require as input a manually ported (or at least functionally similar) code across source and target APIs. To address the shortcoming, this paper proposes TMAP: Text Mining based approach to discover likely API mappings using the similarity in the textual description of the source and target API documents. To evaluate our approach, we used TMAP to discover API mappings for 15 classes across: 1) Java and C# API, and 2) Java ME and Android API. We compared the discovered mappings with state-of-the-art source code analysis based approaches: Rosetta and StaMiner. Our results indicate that TMAP on average found relevant mappings for 57% more methods compared to previous approaches. Furthermore, our results also indicate that TMAP on average found exact mappings for 6.5 more methods per class with a maximum of 21 additional exact mappings for a single class as compared to previous approaches. </td></tr>
<tr id="bib_Pandita2015Discovering" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Pandita2015Discovering,
  title={Discovering likely mappings between APIs using text mining},
  author={Pandita, Rahul and Jetley, Raoul Praful and Sudarsan, Sithu D and Williams, Laurie},
  booktitle={IEEE  International Working Conference on Source Code Analysis and Manipulation},
  pages={231-240},
  year={2015},
 keywords={Java;application program interfaces;data mining;text analysis;API document;API method;Java;TMAP;application programming interface;source code},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Nguyen2015Learning" class="entry">
<li>T. T. Nguyen, H. V. Pham, P. M. Vu, and T. T. Nguyen, "Learning api usages from bytecode: a statistical approach," Computer Science, pp. 416-427, 2015.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Nguyen2015Learning','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Nguyen2015Learning','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Nguyen2015Learning" class="abstract noshow"><td colspan="7"><b>Abstract</b>: When developing mobile apps, programmers rely heavily on standard API frameworks and libraries. However, learning and using those APIs is often challenging due to the fast-changing nature of API frameworks for mobile systems, the complexity of API usages, the insufficiency of documentation, and the unavailability of source code examples. In this paper, we propose a novel approach to learn API usages from bytecode of Android mobile apps. Our core contributions include: i) ARUS, a graph-based representation of API usage scenarios; ii) HAPI, a statistical, generative model of API usages; and iii) three algorithms to extract ARUS from apps' bytecode, to train HAPI based on method call sequences extracted from ARUS, and to recommend method calls in code completion engines using the trained HAPI. Our empirical evaluation suggests that our approach can learn useful API usage models which can provide recommendations with higher levels of accuracy than the baseline n-gram model. </td></tr>
<tr id="bib_Nguyen2015Learning" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Nguyen2015Learning,
  title={Learning API usages from bytecode: a statistical approach},
  author={Nguyen, Tam The and Pham, Hung Viet and Vu, Phong Minh and Nguyen, Tung Thanh},
  journal={Computer Science},
  pages={416-427},
  year={2015},
 keywords={Computer Science - Software Engineering},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Saied2015Mining" class="entry">
<li>M. A. Saied, O. Benomar, H. Abdeen, and H. Sahraoui, "Mining multi-level api usage patterns," in IEEE International Conference on Software Analysis, Evolution and Reengineering, 2015, pp. 23-32.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Saied2015Mining','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Saied2015Mining','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Saied2015Mining" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers need to cope with complexity of Application Programming Interfaces (APIs) of external libraries or frameworks. However, typical APIs provide several thousands of methods to their client programs, and such large APIs are difficult to learn and use. An API method is generally used within client programs along with other methods of the API of interest. Despite this, co-usage relationships between API methods are often not documented. We propose a technique for mining Multi-Level API Usage Patterns (MLUP) to exhibit the co-usage relationships between methods of the API of interest across interfering usage scenarios. We detect multi-level usage patterns as distinct groups of API methods, where each group is uniformly used across variable client programs, independently of usage contexts. We evaluated our technique through the usage of four APIs having up to 22 client programs per API. For all the studied APIs, our technique was able to detect usage patterns that are, almost all, highly consistent and highly cohesive across a considerable variability of client programs. </td></tr>
<tr id="bib_Saied2015Mining" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Saied2015Mining,
  title={Mining Multi-level API Usage Patterns},
  author={Saied, Mohamed Aymen and Benomar, Omar and Abdeen, Hani and Sahraoui, Houari},
  booktitle={IEEE  International Conference on Software Analysis, Evolution and Reengineering},
  pages={23-32},
  year={2015},
 keywords={Software Clustering;API Documentation;API Usage;Usage Pattern},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Gokhale2013Inferring" class="entry">
<li>A. Gokhale, V. Ganapathy, and Y. Padmanaban, "Inferring likely mappings between apis," in International Conference on Software Engineering, 2013, pp. 82-91.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Gokhale2013Inferring','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Gokhale2013Inferring','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Gokhale2013Inferring" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers often need to port applications written for a source platform to a target platform. In doing so, a key task is to replace an application's use of methods from the source platform API with corresponding methods from the target platform API. However, this task is challenging because developers must manually identify mappings between methods in the source and target APIs, e.g., using API documentation. We develop a novel approach to the problem of inferring mappings between the APIs of a source and target platform. Our approach is tailored to the case where the source and target platform each have independently-developed applications that implement similar functionality. We observe that in building these applications, developers exercised knowledge of the corresponding APIs. We develop a technique to systematically harvest this knowledge and infer likely mappings between the APIs of the source and target platform. The output of our approach is a ranked list of target API methods or method sequences that likely map to each source API method or method sequence. We have implemented this approach in a prototype tool called Rosetta, and have applied it to infer likely mappings between the Java2 Platform Mobile Edition and Android graphics APIs. </td></tr>
<tr id="bib_Gokhale2013Inferring" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Gokhale2013Inferring,
  title={Inferring likely mappings between APIs},
  author={Gokhale, Amruta and Ganapathy, Vinod and Padmanaban, Yogesh},
  booktitle={International Conference on Software Engineering},
  pages={82-91},
  year={2013},
 keywords={Java;application program interfaces;software tools;API documentation;API methods;Android graphics APIs;Java2 Platform Mobile Edition;Rosetta;independently-developed applications;mapping inferrence},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Roover2013Multi" class="entry">
<li>C. D. Roover, R. Lammel, and E. Pek, "Multi-dimensional exploration of api usage," in IEEE International Conference on Program Comprehension, 2013, pp. 152-161.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Roover2013Multi','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Roover2013Multi','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Roover2013Multi" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This paper is concerned with understanding API usage in a systematic, explorative manner for the benefit of both API developers and API users. There exist complementary, less explorative methods, e.g., based on code search, code completion, or API documentation. In contrast, our approach is highly interactive and can be seen as an extension of what IDEs readily provide today. Exploration is based on multiple dimensions: i) the hierarchically organized scopes of projects and APIs; ii) metrics of API usage (e.g., number of project classes extending API classes); iii) metadata for APIs; iv) project- versus API-centric views. We also provide the QUAATLAS corpus of Java projects which enhances the existing QUALITAS corpus to enable API-usage analysis. We implemented the exploration approach in an open-source, IDE-like, Web-enabled tool EXAPUS. </td></tr>
<tr id="bib_Roover2013Multi" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Roover2013Multi,
  title={Multi-dimensional exploration of API usage},
  author={Roover, Coen De and Lammel, Ralf and Pek, Ekaterina},
  booktitle={IEEE  International Conference on Program Comprehension},
  pages={152-161},
  year={2013},
 keywords={QUALITAS;API usage;code exploration;metadata;program comprehension;reverse engineering;QUAATLAS;EXAPUS},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Spinuzzi2012Building" class="entry">
<li>C. I. Spinuzzi, J. T. Tempest, A. W. Roesler, and S. G. Mclellan, "Building more usable apis," IEEE Software, vol. 15, no. 3, pp. 78-86, 2012.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Spinuzzi2012Building','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Spinuzzi2012Building','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Spinuzzi2012Building" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Traditional software usability methods can help us design more understandable and more useful application program interfaces (APIs). They also give us information we need to write good API reference documentation-before we invest in either programmers or writers and before evolving a large body of code or content. </td></tr>
<tr id="bib_Spinuzzi2012Building" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Spinuzzi2012Building,
  title={Building More Usable APIs},
  author={Spinuzzi, Clay I. and Tempest, Joseph T. and Roesler, Alvin W. and Mclellan, Samuel G.},
  journal={IEEE Software},
  volume={15},
  number={3},
  pages={78-86},
  year={2012},
 keywords={plane sweep;branching surfaces;polyhedra;surface reconstruction},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Grau2012Jstacs" class="entry">
<li>J. Grau, J. Keilwagen, A. Gohr, B. Haldemann, S. Posch, and I. Grosse, "Jstacs: A java framework for statistical analysis and classification of biological sequences," Journal of Machine Learning Research, vol. 13, no. 1, pp. 1967-1971, 2012.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Grau2012Jstacs','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Grau2012Jstacs','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Grau2012Jstacs" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Jstacs is an object-oriented Java library for analysing and classifying sequence data, which emerged from the need for a standardized implementation of statistical models, learning principles, classifiers, and performance measures. In Jstacs, these components can be used, combined, and extended easily, which allows for a direct comparison of different approaches and fosters the development of new components. Jstacs is especially tailored to biological sequence data, but is also applicable to general discrete and continuous data. Jstacs is freely available at http://www.jstacs.de under the GNU GPL license including an API documentation, a cookbook, and code examples. </td></tr>
<tr id="bib_Grau2012Jstacs" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Grau2012Jstacs,
  title={Jstacs: A Java Framework for Statistical Analysis and Classification of Biological Sequences},
  author={Grau, Jan and Keilwagen, Jens and Gohr, Andr and Haldemann, Berit and Posch, Stefan and Grosse, Ivo},
  journal={Journal of Machine Learning Research},
  volume={13},
  number={1},
  pages={1967-1971},
  year={2012},
 keywords={Java;bioinformatics;classification;machine learning;statistical models},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Uddin2012Temporal" class="entry">
<li>G. Uddin and M. P. Robillard, "Temporal analysis of api usage concepts," in International Conference on Software Engineering, 2012, pp. 804-814.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Uddin2012Temporal','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Uddin2012Temporal','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Uddin2012Temporal" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software reuse through Application Programming Interfaces (APIs) is an integral part of software development. The functionality offered by an API is not always accessed uniformly throughout the lifetime of a client program. We propose Temporal API Usage Pattern Mining to detect API usage patterns in terms of their time of introduction into client programs. We detect concepts as distinct groups of API functionality from the change history of a client program. We locate those concepts in the client change history and detect temporal usage patterns, where a pattern contains a set of concepts that were added into the client program in a specific temporal order. We investigated the properties of temporal API usage patterns through a multiple-case study of three APIs and their use in up to 19 client software projects. Our technique was able to detect a number of valuable patterns in two out of three of the APIs investigated. Further investigation showed some patterns to be relatively consistent between clients, produced by multiple developers, and not trivially derivable from program structure or API documentation. </td></tr>
<tr id="bib_Uddin2012Temporal" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Uddin2012Temporal,
  title={Temporal analysis of API usage concepts},
  author={Uddin, Gias and Robillard, Martin P.},
  booktitle={International Conference on Software Engineering},
  pages={804-814},
  year={2012},
 keywords={application program interfaces;data mining;software reusability;API usage concepts;API usage pattern detection;application programming interfaces;client change history;client program;software development;software reuse},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Wu2010CoDocent" class="entry">
<li>Y. C.Wu, L.W. Mar, and H. C. Jiau, "Codocent: Support api usage with code example and api documentation," in Fifth International Conference on Software Engineering Advances, 2010, pp. 135-140.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Wu2010CoDocent','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Wu2010CoDocent','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Wu2010CoDocent" class="abstract noshow"><td colspan="7"><b>Abstract</b>: API documentation and code example are two major resources to support API usage. To find the best way to use APIs within specific programming tasks, an effective strategy to link related APIs becomes critical. Currently, many code search engines have been proposed to solve this issue. Through those search results, programmers must manually traverse across all API documents to learn the referred API calls. To ensure the productivity in the style of programming with APIs, this work provides CoDocent to help programmers review code examples found by search engines. For each found code example, CoDocent can automatically link related API documents to provide diagrams as abstractions to reflect the semantics of API calls. Two evaluations are conducted to show the effectiveness of CoDocent in investigating and adapting API calls from code examples. </td></tr>
<tr id="bib_Wu2010CoDocent" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Wu2010CoDocent,
  title={CoDocent: Support API Usage with Code Example and API Documentation},
  author={Wu, Ye Chi and Mar, Lee Wei and Jiau, Hewijin Christine},
  booktitle={Fifth International Conference on Software Engineering Advances},
  pages={135-140},
  year={2010},
 keywords={API documentation;programming with APIs;code example},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Acharya2007Mining" class="entry">
<li>M. Acharya, T. Xie, J. Pei, and J. Xu, "Mining api patterns as partial orders from source code: from usage scenarios to specifications," in The Joint Meeting of the European Software Engineering Conference and the ACM Sigsoft Symposium on the Foundations of Software Engineering, 2007, pp. 25-34.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Acharya2007Mining','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Acharya2007Mining','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Acharya2007Mining" class="abstract noshow"><td colspan="7"><b>Abstract</b>: A software system interacts with third-party libraries through various APIs. Using these library APIs often needs to follow certain usage patterns. Furthermore, ordering rules (specifications) exist between APIs, and these rules govern the secure and robust operation of the system using these APIs. But these patterns and rules may not be well documented by the API developers. Previous approaches mine frequent association rules, itemsets, or subsequences that capture API call patterns shared by API client code. However, these frequent API patterns cannot completely capture some useful orderings shared by APIs, especially when multiple APIs are involved across different procedures. In this paper, we present a framework to automatically extract usage scenarios among user-specified APIs as partial orders, directly from the source code (API client code). We adapt a model checker to generate interprocedural control-flow-sensitive static traces related to the APIs of interest. Different API usage scenarios are extracted from the static traces by our scenario extraction algorithm and fed to a miner. The miner summarizes different usage scenarios as compact partial orders. Specifications are extracted from the frequent partial orders using our specification extraction algorithm. Our experience of applying the framework on 72 X11 clients with 200K LOC in total has shown that the extracted API partial orders are useful in assisting effective API reuse and checking. </td></tr>
<tr id="bib_Acharya2007Mining" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Acharya2007Mining,
  title={Mining API patterns as partial orders from source code: from usage scenarios to specifications},
  author={Acharya, Mithun and Xie, Tao and Pei, Jian and Xu, Jun},
  booktitle={The  Joint Meeting of the European Software Engineering Conference and the ACM Sigsoft Symposium on the Foundations of Software Engineering},
  pages={25-34},
  year={2007},
 keywords={API patterns;mining;partial orders;specification;usage scenarios},
}
</pre></td></tr></table><br>
</ol>


<h4><b>(2) <u>Support API Learning and Usage:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">


<table id="qstable" class="sortable" border="0">
<tr id="Pandita2017TMAP" class="entry">
<li>R. Pandita, R. Jetley, S. Sudarsan, T. Menzies, and L. Williams, "Tmap: Discovering relevant api methods through text mining of api documentation," Journal of Software Evolution & Process, vol. 29, no. 12, p. e1845, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Pandita2017TMAP','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Pandita2017TMAP','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Pandita2017TMAP" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Developers often migrate their applications to support various platform/programming-language application programming interfaces (APIs) to retain existing users and to attract new users. To migrate an application written using 1 API (source) to another API (target), a developer must know how the methods in the source API map to the methods in the target API. Given that a typical platform or language exposes a large number of API methods, manually discovering API mappings is prohibitively resource-intensive and may be error prone. The goal of this research is to support software developers in migrating an application from a source API to a target API by automatically discovering relevant method mappings across APIs using text mining on the natural language API method descriptions. This paper proposes text mining based approach (TMAP) to discover relevant API mappings. To evaluate our approach, we used TMAP to discover API mappings for 15 classes across (1) Java and C# API; and (2) Java ME and Android API. We compared the discovered mappings with state-of-the-art source code analysis-based approaches: Rosetta and StaMiner. Our results indicate that TMAP on average found relevant mappings for 56% and 57% more methods compared to the Rosetta and the StaMiner approaches, respectively. </td></tr>
<tr id="bib_Pandita2017TMAP" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Pandita2017TMAP,
  title={TMAP: Discovering relevant API methods through text mining of API documentation},
  author={Pandita, Rahul and Jetley, Raoul and Sudarsan, Sithu and Menzies, Timothy and Williams, Laurie},
  journal={Journal of Software Evolution & Process},
  volume={29},
  number={12},
  pages={e1845},
  year={2017},
 keywords={API documents;API mappings;text mining},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Schwichtenberg2017From" class="entry">
<li>S. Schwichtenberg, C. Gerth, and G. Engels, "From open api to semantic specifications and code adapters," in IEEE International Conference on Web Services, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Schwichtenberg2017From','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Schwichtenberg2017From','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Schwichtenberg2017From" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Today, modern IT-systems are often an interplay of third-party web services. Developers in their role as requesters integrate existing services of different providers into new IT-systems. Providers use frameworks like Open API to create syntactic service specifications from which requesters generate code to integrate services. Proper service discovery is crucial to identify usable services in the growing plethora of third-party services. Most advanced service discovery approaches rely on semantic specifications, e.g., OWL-S. While semantic specifications are crucial for a precise discovery, syntactical specification are needed for service invocation. To close the gap between semantic and syntactic specifications, service grounding establishes links between the semantic and syntactic specifications. However, for a large number of web services still no semantic specification or grounding exists. In this paper, we present an approach that semi-automates the semantic specification of web services for service providers and additionally helps service requesters to leverage semantic web services. Our approach enables a higher degree of automation than other approaches. This includes the creation of semantic specifications and service groundings for service providers as well as the integration of services for requesters by using our code generator. As proof-of-concept, we provide a case study, where we derive a sophisticated semantic OWL-S specification from a syntactic Open API specification. </td></tr>
<tr id="bib_Schwichtenberg2017From" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Schwichtenberg2017From,
  title={From Open API to Semantic Specifications and Code Adapters},
  author={Schwichtenberg, Simon and Gerth, Christian and Engels, Gregor},
  booktitle={IEEE International Conference on Web Services},
  year={2017},
 keywords={Open API;RESTful;Grounding;Semantic Web Services;Lifting;Lowering;Adapter Generation;Service Invocation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Jiang2017Docio" class="entry">
<li>S. Jiang, A. Armaly, C. Mcmillan, Q. Zhi, and R. Metoyer, "Docio: Documenting api input/output examples," in Ieee/acm International Conference on Program Comprehension, 2017, pp. 364-367.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Jiang2017Docio','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Jiang2017Docio','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Jiang2017Docio" class="abstract noshow"><td colspan="7"><b>Abstract</b>: When learning to use an Application Programming Interface (API), programmers need to understand the inputs and outputs (I/O) of the API functions. Current documentation tools automatically document the static information of I/O, such as parameter types and names. What is missing from these tools is dynamic information, such as I/O examples鈥攁ctual valid values of inputs that produce certain outputs. In this paper, we demonstrate Docio, a prototype toolset we built to generate I/O examples. Docio logs I/O values when API functions are executed, for example in running test suites. Then, Docio puts I/O values into API documents as I/O examples. Docio has three programs: 1) funcWatch, which collects I/O values when API developers run test suites, 2) ioSelect, which selects one I/O example from a set of I/O values, and 3) ioPresent, which embeds the I/O examples into documents. In a preliminary evaluation, we used Docio to generate four hundred I/O examples for three C libraries: ffmpeg, libssh, and protobuf-c. Docio is open-source and available at: http://www3.nd.edu/~sjiang1/docio/. </td></tr>
<tr id="bib_Jiang2017Docio" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Jiang2017Docio,
  title={Docio: Documenting API Input/Output Examples},
  author={Jiang, Siyuan and Armaly, Ameer and Mcmillan, Collin and Zhi, Qiyu and Metoyer, Ronald},
  booktitle={Ieee/acm  International Conference on Program Comprehension},
  pages={364-367},
  year={2017},
 keywords={api documentation;program comprehension;dynamic program analysis},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Van2016Characterizing" class="entry">
<li>T. Van Nguyen, A. T. Nguyen, and T. N. Nguyen, "Characterizing api elements in software documentation with vector representation," pp. 749-751, 2016.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Van2016Characterizing','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Van2016Characterizing','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Van2016Characterizing" class="abstract noshow"><td colspan="7"><b>Abstract</b>: In software engineering (SE), documentation for developers (e.g., developers' guide, API documentation), users' documentation, informal documentation [7, 13] (e.g., developers' forums, mailing lists, development communities' discussions, etc.), and issue reports are of much interest for software engineers. This so-called software documentation is a crucial resource for them in understanding various aspects of a software development process. </td></tr>
<tr id="bib_Van2016Characterizing" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Van2016Characterizing,
  title={Characterizing API elements in software documentation with vector representation},
  author={Van Nguyen, Thanh and Nguyen, Anh Tuan and Nguyen, Tien N},
  pages={749-751},
  year={2016},
 keywords={Word2Vec;software documentation;software libraries},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Gadea2016A" class="entry">
<li>C. Gadea, M. Trifan, D. Ionescu, and B. Ionescu, "A reference architecture for real-time microservice api consumption," pp. 1- 6, 2016.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Gadea2016A','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Gadea2016A','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Gadea2016A" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Modern web frameworks and backend-as-a-service providers make it possible for real-time updates to a NoSQL data model to be reflected in the user interfaces of multiple subscribing end-user applications. However, it remains difficult for users to dynamically discover and instantly make use of the data provided by the plethora of REST APIs in existence across various cloud providers today. This paper presents a reference architecture built on the idea of a scalable NoSQL database that allows multiple subscribers to receive instant notifications of database changes through the use of a "livequery". By keeping one WebSocket connection open between each client web browser and an Object Synchronization Server, this paper shows how data from multiple disparate REST APIs can be organized and transmitted to interested clients via the database. An example is given featuring a collaborative rich-text editor that makes use of a Named-Entity Recognition microservice. </td></tr>
<tr id="bib_Gadea2016A" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Gadea2016A,
  title={A reference architecture for real-time microservice API consumption},
  author={Gadea, Cristian and Trifan, Mircea and Ionescu, Dan and Ionescu, Bogdan},
  pages={1-6},
  year={2016},
 keywords={cloud computing;collaborative editing;docker;microservices;named entity recognition;real-time web},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Salvadori2015A" class="entry">
<li>I. Salvadori and F. Siqueira, "A maturity model for semantic restful web apis," in IEEE International Conference on Web Services, 2015, pp. 703-710.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Salvadori2015A','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Salvadori2015A','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Salvadori2015A" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Web APIs provide interfaces for interaction among systems based on the existing infrastructure for hosting Web sites and applications. The REST architectural style is the most employed approach for building Web APIs. However, the flexibility provided by REST may result in implementations with low quality design, limited reuse and poor documentation. This paper describes a maturity model for classifying Web APIs, aimed at promoting the adherence to REST architectural principles and the adoption of semantic Web technology in order to improve the design, reuse and documentation of Web APIs. </td></tr>
<tr id="bib_Salvadori2015A" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Salvadori2015A,
  title={A Maturity Model for Semantic RESTful Web APIs},
  author={Salvadori, Ivan and Siqueira, Frank},
  booktitle={IEEE International Conference on Web Services},
  pages={703-710},
  year={2015},
 keywords={Semantic Web;Maturity Model;REST;Web API;Linked Data},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Corona2014Lux0R" class="entry">
<li>I. Corona, D. Maiorca, D. Ariu, and G. Giacinto, "Lux0r: Detection of malicious pdf-embedded javascript code through discriminant analysis of api references," in The Workshop on Artificial Intelligent and Security Workshop, 2014, pp. 47-57.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Corona2014Lux0R','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Corona2014Lux0R','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Corona2014Lux0R" class="abstract noshow"><td colspan="7"><b>Abstract</b>: JavaScript is a dynamic programming language adopted in a variety of applications, including web pages, PDF Readers, widget engines, network platforms, office suites. Given its widespread presence throughout different software platforms, JavaScript is a primary tool for the development of novel -rapidly evolving- malicious exploits. If the classical signature- and heuristic-based detection approaches are clearly inadequate to cope with this kind of threat, machine learning solutions proposed so far suffer from high false-alarm rates or require special instrumentation that make them not suitable for protecting end-user systems. In this paper we present Lux0R "Lux 0n discriminant References", a novel, lightweight approach to the detection of malicious JavaScript code. Our method is based on the characterization of JavaScript code through its API references, i.e., functions, constants, objects, methods, keywords as well as attributes natively recognized by a JavaScript Application Programming Interface (API). We exploit machine learning techniques to select a subset of API references that characterize malicious code, and then use them to detect JavaScript malware. The selection algorithm has been thought to be "secure by design" against evasion by mimicry attacks. In this investigation, we focus on a relevant application domain, i.e., the detection of malicious JavaScript code within PDF documents. We show that our technique is able to achieve excellent malware detection accuracy, even on samples exploiting never-before-seen vulnerabilities, i.e., for which there are no examples in training data. Finally, we experimentally assess the robustness of Lux0R against mimicry attacks based on feature addition. </td></tr>
<tr id="bib_Corona2014Lux0R" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Corona2014Lux0R,
  title={Lux0R: Detection of Malicious PDF-embedded JavaScript code through Discriminant Analysis of API References},
  author={Corona, Igino and Maiorca, Davide and Ariu, Davide and Giacinto, Giorgio},
  booktitle={The Workshop on Artificial Intelligent and Security Workshop},
  pages={47-57},
  year={2014},
 keywords={adversarial machine learning;javascript code;malware detection;mimicry attacks;pdf documents},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Bagge2014Specification" class="entry">
<li>A. H. Bagge and M. Haveraaen, "Specification of generic apis, or: why algebraic may be better than pre/post," Acm Sigada Ada Letters, vol. 34, no. 3, pp. 71-80, 2014.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Bagge2014Specification','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Bagge2014Specification','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Bagge2014Specification" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Specification based on Floyd-Hoare logic, using pre and postconditions, is common in languages aimed at high integrity software. Such pre/postcondition specifications are geared towards verification of code. While this specification technique has proven quite successful in the past 40 years, it has limitations when applied to API specification, particularly specification of generic interfaces. API-oriented design and genericity is of particular importance in modern large-scale software development. In this situation, algebraic specification techniques have a significant advantage. Unlike pre/post-based specification, which deals with the inputs and outputs of one operation at a time, algebraic specification deals with the relationships between the different operations in an API, which is needed in the specification of generic APIs. </td></tr>
<tr id="bib_Bagge2014Specification" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Bagge2014Specification,
  title={Specification of generic APIs, or: why algebraic may be better than pre/post},
  author={Bagge, Anya Helene and Haveraaen, Magne},
  journal={Acm Sigada Ada Letters},
  volume={34},
  number={3},
  pages={71-80},
  year={2014},
 keywords={api specification;apis;axioms;generic programming;program specification},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Endrikat2014How" class="entry">
<li>S. Endrikat, S. Hanenberg, R. Robbes, and A. Stefik, How do API documentation and static typing affect API usability? ACM, 2014.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Endrikat2014How','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Endrikat2014How','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Endrikat2014How" class="abstract noshow"><td colspan="7"><b>Abstract</b>: When developers use Application Programming Interfaces (APIs), they often rely on documentation to assist their tasks. In previous studies, we reported evidence indicating that static type systems acted as a form of implicit documentation, benefiting developer productivity. Such implicit documentation is easier to maintain, given it is enforced by the compiler, but previous experiments tested users without any explicit documentation. In this paper, we report on a controlled experiment and an exploratory study comparing the impact of using documentation and a static or dynamic type system on a development task. Results of our study both confirm previous findings and show that the benefits of static typing are strengthened with explicit documentation, but that this was not as strongly felt with dynamically typed languages. </td></tr>
<tr id="bib_Endrikat2014How" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@book{Endrikat2014How,
  title={How do API documentation and static typing affect API usability?},
  author={Endrikat, Stefan and Hanenberg, Stefan and Robbes, Romain and Stefik, Andreas},
  publisher={ACM},
  pages={632-642},
  year={2014},
 keywords={API Usability;Documentation;Static Type Systems},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Inozemtseva2014Integrating" class="entry">
<li>L. Inozemtseva, S. Subramanian, and R. Holmes, Integrating software project resources using source code identifiers, 2014.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Inozemtseva2014Integrating','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Inozemtseva2014Integrating','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Inozemtseva2014Integrating" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Source code identifiers such as classes, methods, and fields appear in many different contexts. For instance, a developer performing a task using the android.app.Activity class could consult various project resources including the class's source file, API documentation, issue tracker, mailing list discussions, code reviews, or questions on Stack Overflow. These information sources are logically connected by the source code elements they describe, but are generally decoupled from each other. This has historically been tolerated by developers, since there was no obvious way to easily navigate between the data sources. However, it is now common for these sources to have web-based front ends that provide a standard mechanism (the browser) for viewing and interacting with the data they contain. Augmenting these front ends with hyperlinks and search would make development easier by allowing developers to quickly navigate between disparate sources of information about the same code element. In this paper, we propose a method of automatically linking disparate information repositories with an emphasis on high precision. We also propose a method of augmenting web-based front ends with these links to make it easier for developers to quickly gain a comprehensive view of the source code elements they are investigating. Research challenges include identifying source code tokens in the midst of natural language text and incomplete code fragments, dynamically augmenting the web views of the data repositories, and supporting novel composition of the link data to provide comprehensive views for specific source code elements. </td></tr>
<tr id="bib_Inozemtseva2014Integrating" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@book{Inozemtseva2014Integrating,
  title={Integrating software project resources using source code identifiers},
  author={Inozemtseva, Laura and Subramanian, Siddharth and Holmes, Reid},
  year={2014},
 keywords={Newton;Traceability;semantic links},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Grau2012Jstacs" class="entry">
<li>J. Grau, J. Keilwagen, A. Gohr, B. Haldemann, S. Posch, and I. Grosse, "Jstacs: A java framework for statistical analysis and classification of biological sequences," Journal of Machine Learning Research, vol. 13, no. 1, pp. 1967-1971, 2012.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Grau2012Jstacs','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Grau2012Jstacs','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Grau2012Jstacs" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Jstacs is an object-oriented Java library for analysing and classifying sequence data, which emerged from the need for a standardized implementation of statistical models, learning principles, classifiers, and performance measures. In Jstacs, these components can be used, combined, and extended easily, which allows for a direct comparison of different approaches and fosters the development of new components. Jstacs is especially tailored to biological sequence data, but is also applicable to general discrete and continuous data. Jstacs is freely available at http://www.jstacs.de under the GNU GPL license including an API documentation, a cookbook, and code examples.</td></tr>
<tr id="bib_Grau2012Jstacs" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Grau2012Jstacs,
  title={Jstacs: A Java Framework for Statistical Analysis and Classification of Biological Sequences},
  author={Grau, Jan and Keilwagen, Jens and Gohr, Andr and Haldemann, Berit and Posch, Stefan and Grosse, Ivo},
  journal={Journal of Machine Learning Research},
  volume={13},
  number={1},
  pages={1967-1971},
  year={2012},
 keywords={Java;bioinformatics;classification;machine learning;statistical models},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Pradel2012Statically" class="entry">
<li>M. Pradel, C. Jaspan, J. Aldrich, and T. R. Gross, "Statically checking api protocol conformance with mined multi-object specifications," in International Conference on Software Engineering, 2012, pp. 925-935.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Pradel2012Statically','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Pradel2012Statically','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Pradel2012Statically" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Programmers using an API often must follow protocols that specify when it is legal to call particular methods. Several techniques have been proposed to find violations of such protocols based on mined specifications. However, existing techniques either focus on single-object protocols or on particular kinds of bugs, such as missing method calls. There is no practical technique to find multi-object protocol bugs without a priori known specifications. In this paper, we combine a dynamic analysis that infers multi-object protocols and a static checker of API usage constraints into a fully automatic protocol conformance checker. The combined system statically detects illegal uses of an API without human-written specifications. Our approach finds 41 bugs and code smells in mature, real-world Java programs with a true positive rate of 51%. Furthermore, we show that the analysis reveals bugs not found by state of the art approaches. </td></tr>
<tr id="bib_Pradel2012Statically" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Pradel2012Statically,
  title={Statically checking API protocol conformance with mined multi-object specifications},
  author={Pradel, Michael and Jaspan, Ciera and Aldrich, Jonathan and Gross, Thomas R.},
  booktitle={International Conference on Software Engineering},
  pages={925-935},
  year={2012},
 keywords={Specification mining;Typestate;Static analysis},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Robillard2011A" class="entry">
<li>M. P. Robillard and R. Deline, "A field study of api learning obstacles," Empirical Software Engineering, vol. 16, no. 6, pp. 703- 732, 2011.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Robillard2011A','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Robillard2011A','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Robillard2011A" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Large APIs can be hard to learn, and this can lead to decreased programmer productivity. But what makes APIs hard to learn? We conducted a mixed approach, multi-phased study of the obstacles faced by Microsoft developers learning a wide variety of new APIs. The study involved a combination of surveys and in-person interviews, and collected the opinions and experiences of over 440 professional developers. We found that some of the most severe obstacles faced by developers learning new APIs pertained to the documentation and other learning resources. We report on the obstacles developers face when learning new APIs, with a special focus on obstacles related to API documentation. Our qualitative analysis elicited five important factors to consider when designing API documentation: documentation of intent; code examples; matching APIs with scenarios; penetrability of the API; and format and presentation. We analyzed how these factors can be interpreted to prioritize API documentation development efforts </td></tr>
<tr id="bib_Robillard2011A" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Robillard2011A,
  title={A field study of API learning obstacles},
  author={Robillard, Martin P and Deline, Robert},
  journal={Empirical Software Engineering},
  volume={16},
  number={6},
  pages={703-732},
  year={2011},
 keywords={Application programming interfaces;Software libraries;Programming;Documentation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Yilmaz2011ACART" class="entry">
<li>L. Yilmaz and D. Kent, "Acart: an api compliance and analysis report tool for discovering reference design traceability," in Southeast Regional Conference, 2011, pp. 243-248.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Yilmaz2011ACART','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Yilmaz2011ACART','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Yilmaz2011ACART" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The compliance of individual software modules with standard API specifications is critical to create a maintainable and portable software system over the long-term. Even minor shortfalls in API compliance can result in the need for extensive software maintenance. We present an API Compliance and Analysis Report Tool (ACART) that measures and visualizes the degree of compliance of software with an IDL-based specification. A discrete optimization method for finding maximal mapping between a reference API and sourcecode is presented. The optimization technique uses lexical and structural similarity metrics to find a mapping that minimizes the distance between the reference IDL specification and the specification derived from the sourcecode. A prototype is developed to verify and demonstrate the validity of the approach. </td></tr>
<tr id="bib_Yilmaz2011ACART" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Yilmaz2011ACART,
  title={ACART: an API Compliance and Analysis Report Tool for discovering reference design traceability},
  author={Yilmaz, Levent and Kent, David},
  booktitle={Southeast Regional Conference},
  pages={243-248},
  year={2011},
 keywords={API analysis;interface verification;testing;traceability;verification},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Zhang2011Flow" class="entry">
<li>Q. Zhang, W. Zheng, and M. R. Lyu, "Flow-augmented call graph: A new foundation for taming api complexity," vol. 6603, pp. 386-400, 2011.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Zhang2011Flow','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Zhang2011Flow','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Zhang2011Flow" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software systems often undergo significant changes in their life cycle, exposing increasingly complex API to their developers. Without methodical guidances, it is easy to become bogged down in a morass of complex API even for the professional software developers. This paper presents the Flow-Augmented Call Graph (FACG) for taming API complexity. Augmenting the call graph with control flow analysis brings us a new insight to capture the significance of the caller-callee linkages in the call graph. We apply the proposed FACG in API recommendation and compare our approach with the state-of-the-art approaches in the same domain. The evaluation result indicates that our approach is more effective in retrieving the relevant APIs with regard to the original API documentation. </td></tr>
<tr id="bib_Zhang2011Flow" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Zhang2011Flow,
  title={Flow-Augmented Call Graph: A New Foundation for Taming API Complexity},
  author={Zhang, Qirun and Zheng, Wujie and Lyu, Michael R.},
  volume={6603},
  pages={386-400},
  year={2011},
 keywords={API Recommendation;Static Analysis;Control Flow Analysis},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Eisenberg2010Apatite" class="entry">
<li>D. S. Eisenberg, J. Stylos, and B. A. Myers, "Apatite:a new interface for exploring apis," in International Conference on Human Factors in Computing Systems, CHI 2010, Atlanta, Georgia, Usa, April, 2010, pp. 1331-1334.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Eisenberg2010Apatite','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Eisenberg2010Apatite','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Eisenberg2010Apatite" class="abstract noshow"><td colspan="7"><b>Abstract</b>: We present Apatite, a new tool that aids users in learning and understanding a complex API by visualizing the common associations between its various components. Current object-oriented API documentation is usually navigated in a fixed tree structure, starting with a package and then filtering by a specific class. For large APIs, this scheme is overly restrictive, because it prevents users from locating a particular action without first knowing which class it belongs to. Apatite's design instead enables users to search across any level of an API's hierarchy. This is made possible by the introduction of a novel interaction technique that presents popular items from multiple categories simultaneously, determining their relevance by approximating the strength of their association using search engine data. The design of Apatite was refined through iterative usability testing, and it has been released publicly as a web application. </td></tr>
<tr id="bib_Eisenberg2010Apatite" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Eisenberg2010Apatite,
  title={Apatite:a new interface for exploring APIs},
  author={Eisenberg, Daniel S. and Stylos, Jeffrey and Myers, Brad A.},
  booktitle={International Conference on Human Factors in Computing Systems, CHI 2010, Atlanta, Georgia, Usa, April},
  pages={1331-1334},
  year={2010},
 keywords={api documentation;browsing;search tools;visualizations;web applications},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Nasehi2010Unit" class="entry">
<li>S. M. Nasehi and F. Maurer, "Unit tests as api usage examples," in IEEE International Conference on Software Maintenance, 2010, pp. 1-10.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Nasehi2010Unit','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Nasehi2010Unit','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Nasehi2010Unit" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This study aims to find out if API unit tests can provide good usage examples, and if so, what prevents developers from finding and using those examples. The results of an experiment we performed with two groups of developers showed that unit tests can be very helpful, especially when the task is complicated and involves multiple classes and methods. Well-written tests proved to be a good source of examples, but finding the relevant examples using the standard tools might be very difficult. We propose to supplement the standard API documentation with relevant examples taken from the unit tests. To further improve the learnability of the API, presentation of the documentation and examples has to be tailored in a way that separates or hides advanced usage scenarios from the commonly used ones. </td></tr>
<tr id="bib_Nasehi2010Unit" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Nasehi2010Unit,
  title={Unit tests as API usage examples},
  author={Nasehi, Seyed Mehdi and Maurer, Frank},
  booktitle={IEEE International Conference on Software Maintenance},
  pages={1-10},
  year={2010},
 keywords={Code Example;API;Usability;Unit Test;Documentation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Stylos2008The" class="entry">
<li>J. Stylos and B. A. Myers, "The implications of method placement on api learnability," in ACM Sigsoft International Symposium on Foundations of Software Engineering, 2008, pp. 105-112.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Stylos2008The','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Stylos2008The','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Stylos2008The" class="abstract noshow"><td colspan="7"><b>Abstract</b>: To better understand what makes Application Programming Interfaces (APIs) hard to use and how to improve them, recent research has begun studying programmers' strategies and use of APIs. It was found that method placement --- on which class or classes a method is placed --- can have large usability impact in object-oriented APIs. This was because programmers often start their exploration of an API from one "main" object, and were slower finding other objects that were not referenced in the methods of the main object. For example, while mailServer.send(mailMessage) might make sense, if programmers often begin their API explorations from the MailMessage class, then this makes it harder to find the MailServer class than the alternative mailMessage.send(mailServer). This is interesting because many real APIs place methods essential to common objects on other, helper objects. Alternate versions of three different APIs were compared, and it was found that programmers gravitated toward the same starting classes and were dramatically faster --- between 2 to 11 times --- combining multiple objects when a method on the starting class referred to the other class. </td></tr>
<tr id="bib_Stylos2008The" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Stylos2008The,
  title={The implications of method placement on API learnability},
  author={Stylos, Jeffrey and Myers, Brad A.},
  booktitle={ACM Sigsoft International Symposium on Foundations of Software Engineering},
  pages={105-112},
  year={2008},
 keywords={APIs;documentation;frameworks;libraries;usability;user studies},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Gonzalez2005Platform" class="entry">
<li>A. Gonzalez and L. G. Reid, "Platform-independent accessibility api: accessible document object model," in International Cross- Disciplinary Workshop on Web Accessibility, 2005, pp. 63-71.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Gonzalez2005Platform','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Gonzalez2005Platform','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Gonzalez2005Platform" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This paper addresses the problem of supporting accessibility in applications that run in multiple operating environments. It analyzes the commonalities of existing platform-specific Accessibility APIs, and defines a platform-independent accessibility API, the Accessible DOM.The Accessible DOM encompasses the features of existing APIs and overcomes the limitations of existing APIs to express dynamic, complex document contents.The Accessible DOM can be used to support existing and future platform-specific accessibility APIs. It will also allow the development of platform-independent accessibility clients. </td></tr>
<tr id="bib_Gonzalez2005Platform" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Gonzalez2005Platform,
  title={Platform-independent accessibility API: accessible document object model},
  author={Gonzalez, Andres and Reid, Loretta Guarino},
  booktitle={International Cross-Disciplinary Workshop on Web Accessibility},
  pages={63-71},
  year={2005},
 keywords={W3C DOM;accessibility API},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Pierce2002Automatically" class="entry">
<li>R. Pierce and S. Tilley, "Automatically connecting documentation to code with rose," in International Conference on Computer Documentation, 2002, pp. 157-163.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Pierce2002Automatically','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Pierce2002Automatically','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Pierce2002Automatically" class="abstract noshow"><td colspan="7"><b>Abstract</b>: One of the most common problems with program documentation is keeping it synchronized with the source code it purports to explain. One solution to this problem is to automate the documentation process using reverse engineering technology. Reverse engineering is an emerging branch of software engineering that focuses on recreating high-level information (such as program documentation) from low-level artifacts (such as source code). This paper describes an automated approach to maintaining the connection between documentation and code by leveraging the reverse engineering capabilities built-in to Rational Rose. The approach produces application programming interface documentation for component object model-based (COM) dynamic link libraries (DLLs), C++ source code, and Java archive files. The documentation is always accurate and up-to-date. A primary advantage of the approach is its reliance on an industry-standard tool, thereby addressing one of the main concerns with facilitating wide-spread tool adoption: commercial-level support of deployed products. </td></tr>
<tr id="bib_Pierce2002Automatically" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Pierce2002Automatically,
  title={Automatically connecting documentation to code with rose},
  author={Pierce, Robert and Tilley, Scott},
  booktitle={International Conference on Computer Documentation},
  pages={157-163},
  year={2002},
 keywords={application programming interface (API;automation;documentation;single sourcing;software engineering},
}
</pre></td></tr></table><br>


</ol>


<h4><b>(3) <u>Enhance API or Code Recommendation:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">








<table id="qstable" class="sortable" border="0">
<tr id="Ye2017From" class="entry">
<li>X. Ye, H. Shen, X. Ma, R. Bunescu, and C. Liu, "From word embeddings to document similarities for improved information retrieval in software engineering," in Ieee/acm International Conference on Software Engineering, 2017, pp. 404-415.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Ye2017From','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Ye2017From','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Ye2017From" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The application of information retrieval techniques to search tasks in software engineering is made difficult by the lexical gap between search queries, usually expressed in natural language (e.g. English), and retrieved documents, usually expressed in code (e.g. programming languages). This is often the case in bug and feature location, community question answering, or more generally the communication between technical personnel and non-technical stake holders in a software project. In this paper, we propose bridging the lexical gap by projecting natural language statements and code snippets as meaning vectors in a shared representation space. In the proposed architecture, word embeddings are rst trained on API documents, tutorials, and reference documents, and then aggregated in order to estimate semantic similarities between documents. Empirical evaluations show that the learned vector space embeddings lead to improvements in a previously explored bug localization task and a newly de ned task of linking API documents to computer programming questions. </td></tr>
<tr id="bib_Ye2017From" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Ye2017From,
  title={From Word Embeddings to Document Similarities for Improved Information Retrieval in Software Engineering},
  author={Ye, Xin and Shen, Hui and Ma, Xiao and Bunescu, Razvan and Liu, Chang},
  booktitle={Ieee/acm  International Conference on Software Engineering},
  pages={404-415},
  year={2017},
 keywords={word embeddings;skip-gram model;bug localization;bug reports;API documents},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Vaziri2017Generating" class="entry">
<li>M. Vaziri, L. Mandel, A. Shinnar, J. Simon, and M. Hirzel, "Generating chat bots from web api specifications," in ACM Sigplan International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software, 2017, pp. 44-57.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Vaziri2017Generating','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Vaziri2017Generating','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Vaziri2017Generating" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Companies want to offer chat bots to their customers and employees which can answer questions, enable self-service, and showcase their products and services. Implementing and maintaining chat bots by hand costs time and money. Companies typically have web APIs for their services, which are often documented with an API specification. This paper presents a compiler that takes a web API specification written in Swagger and automatically generates a chat bot that helps the user make API calls. The generated bot is self-documenting, using descriptions from the API specification to answer help requests. Unfortunately, Swagger specifications are not always good enough to generate high-quality chat bots. This paper addresses this problem via a novel in-dialogue curation approach: the power user can improve the generated chat bot by interacting with it. The result is then saved back as an API specification. This paper reports on the design and implementation of the chat bot compiler, the in-dialogue curation, and working case studies. </td></tr>
<tr id="bib_Vaziri2017Generating" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Vaziri2017Generating,
  title={Generating chat bots from web API specifications},
  author={Vaziri, Mandana and Mandel, Louis and Shinnar, Avraham and Siméon, Jérôme and Hirzel, Martin},
  booktitle={ACM Sigplan International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
  pages={44-57},
  year={2017},
 keywords={Conversational agents;REST;cloud;compilers},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Yuan2017APIBot" class="entry">
<li>T. Yuan, F. Thung, A. Sharma, and D. Lo, "Apibot: Question answering bot for api documentation," in Ieee/acm International Conference on Automated Software Engineering, 2017, pp. 153-158.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Yuan2017APIBot','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Yuan2017APIBot','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Yuan2017APIBot" class="abstract noshow"><td colspan="7"><b>Abstract</b>: As the carrier of Application Programming Interfaces (APIs) knowledge, API documentation plays a crucial role in how developers learn and use an API. It is also a valuable information resource for answering API-related questions, especially when developers cannot find reliable answers to their questions online/offline. However, finding answers to API-related questions from API documentation might not be easy because one may have to manually go through multiple pages before reaching the relevant page, and then read and understand the information inside the relevant page to figure out the answers. To deal with this challenge, we develop APIBot, a bot that can answer API questions given API documentation as an input. APIBot is built on top of SiriusQA, the QA system from Sirius, a state of the art intelligent personal assistant. To make SiriusQA work well under software engineering scenario, we make several modifications over SiriusQA by injecting domain specific knowledge. We evaluate APIBot on 92 API questions, answers of which are known to be present in Java 8 documentation. Our experiment shows that APIBot can achieve a Hit@5 score of 0.706. </td></tr>
<tr id="bib_Yuan2017APIBot" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Yuan2017APIBot,
  title={APIBot: Question answering bot for API documentation},
  author={Yuan, Tian and Thung, Ferdian and Sharma, Abhishek and Lo, David},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={153-158},
  year={2017},
 keywords={ieee computer society},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Ghafari2014Towards" class="entry">
<li>M. Ghafari and A. Heydarnoori, Towards a visualized code recommendation for APIs enriched with specification mining. ACM, 2014.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Ghafari2014Towards','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Ghafari2014Towards','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Ghafari2014Towards" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This paper positions an idea for an interactive code recommendation system. In this work, candidate recommendations are abstracted as a graph-based visualization of the API usages that are decorated with the API specifications and the usage rules mined from the unit test cases of the given API and its usage examples. The user can then progressively explore this graph to obtain her desired code without delving into the implementation details. </td></tr>
<tr id="bib_Ghafari2014Towards" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@book{Ghafari2014Towards,
  title={Towards a visualized code recommendation for APIs enriched with specification mining},
  author={Ghafari, Mohammad and Heydarnoori, Abbas},
  publisher={ACM},
  pages={26-27},
  year={2014},
 keywords={Code recommendation;specification;unit test;visualization},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Tran2013API" class="entry">
<li>D. H. Tran and H. P. Nguyen, "Api specification-based function search engine using natural language query," in International Conference on Computing, Management and Telecommunications, 2013, pp. 140-145.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Tran2013API','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Tran2013API','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Tran2013API" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Programmers nearly always use existing functions while developing their applications. However, the functions have grown more numerous and more diverse while the applications have grown more dependent on them. Thus, it's difficult for programmers to find what functions they want and know how to call those functions [1]. This paper present two novel approaches to address these problems. The first is the approach to find right functions based on the API specification. This approach can search suitable functions by their functionalities described in the API specification. The second is approach to automatically generate code for “function call‿. In the second approach, programmer can call a function by natural language query. We have implemented a function search engine for Java, called FSE. Besides, we have also performed some evaluations to demonstrate that FSE is better than the existing online search engines in precision and recall. </td></tr>
<tr id="bib_Tran2013API" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Tran2013API,
  title={API specification-based function search engine using natural language query},
  author={Tran, Dinh Huy and Nguyen, Hua Phung},
  booktitle={International Conference on Computing, Management and Telecommunications},
  pages={140-145},
  year={2013},
 keywords={natural language processing;Code search engine;API specification;software reuse},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Mishne2012Typestate" class="entry">
<li>A. Mishne, S. Shoham, and E. Yahav, "Typestate-based semantic code search over partial programs," Acm Sigplan Notices, vol. 47, no. 10, pp. 997-1016, 2012.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Mishne2012Typestate','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Mishne2012Typestate','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Mishne2012Typestate" class="abstract noshow"><td colspan="7"><b>Abstract</b>: We present a novel code search approach for answering queries focused on API-usage with code showing how the API should be used. To construct a search index, we develop new techniques for statically mining and consolidating temporal API specifications from code snippets. In contrast to existing semantic-based techniques, our approach handles partial programs in the form of code snippets. Handling snippets allows us to consume code from various sources such as parts of open source projects, educational resources (e.g. tutorials), and expert code sites. To handle code snippets, our approach (i) extracts a possibly partial temporal specification from each snippet using a relatively precise static analysis tracking a generalized notion of typestate, and (ii) consolidates the partial temporal specifications, combining consistent partial information to yield consolidated temporal specifications, each of which captures a full(er) usage scenario. To answer a search query, we define a notion of relaxed inclusion matching a query against temporal specifications and their corresponding code snippets. We have implemented our approach in a tool called PRIME and applied it to search for API usage of several challenging APIs. PRIME was able to analyze and consolidate thousands of snippets per tested API, and our results indicate that the combination of a relatively precise analysis and consolidation allowed PRIME to answer challenging queries effectively. </td></tr>
<tr id="bib_Mishne2012Typestate" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Mishne2012Typestate,
  title={Typestate-based semantic code search over partial programs},
  author={Mishne, Alon and Shoham, Sharon and Yahav, Eran},
  journal={Acm Sigplan Notices},
  volume={47},
  number={10},
  pages={997-1016},
  year={2012},
 keywords={code search engine;ranking code samples;specification mining;static analysis;typestate},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Mooty2010Calcite" class="entry">
<li>M. Mooty, A. Faulring, J. Stylos, and B. A. Myers, "Calcite: Completing code completion for constructors using crowds," in Visual Languages and Human-Centric Computing, 2010, pp. 15-22.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Mooty2010Calcite','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Mooty2010Calcite','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Mooty2010Calcite" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Calcite is a new Eclipse plugin that helps address the difficulty of understanding and correctly using an API. Calcite finds the most popular ways to instantiate a given class or interface by using code examples. To allow the users to easily add these object instantiations to their code, Calcite adds items to the popup completion menu that will insert the appropriate code into the user’s program. Calcite also uses crowd sourcing to add to the menu instructions in the form of comments that help the user perform functions that people have identified as missing from the API. In a user study, Calcite improved users‿ success rate by 40%. </td></tr>
<tr id="bib_Mooty2010Calcite" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Mooty2010Calcite,
  title={Calcite: Completing Code Completion for Constructors Using Crowds},
  author={Mooty, Mathew and Faulring, Andrew and Stylos, Jeffrey and Myers, Brad A.},
  booktitle={Visual Languages and Human-Centric Computing},
  pages={15-22},
  year={2010},
 keywords={Crowdsourcing;Eclipse;API Documentation;Natural Programming},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Mcmillan2010Recommending" class="entry">
<li>C. Mcmillan, D. Poshyvanyk, and M. Grechanik, "Recommending source code examples via api call usages and documentation," in International Workshop on Recommendation Systems for Software Engineering, 2010, pp. 21-25.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Mcmillan2010Recommending','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Mcmillan2010Recommending','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Mcmillan2010Recommending" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Online source code repositories contain software projects that already implement certain requirements that developers must fulfill. Programmers can reuse code from these existing projects if they can find relevant code without significant effort. We propose a new method to recommend source code examples to developers by querying against Application Programming Interface (API) calls and their documentations that are fused with structural information about the code. We conducted an empirical evaluation that suggests that our approach is lightweight and accurate. </td></tr>
<tr id="bib_Mcmillan2010Recommending" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Mcmillan2010Recommending,
  title={Recommending source code examples via API call usages and documentation},
  author={Mcmillan, Collin and Poshyvanyk, Denys and Grechanik, Mark},
  booktitle={International Workshop on Recommendation Systems for Software Engineering},
  pages={21-25},
  year={2010},
}
</pre></td></tr></table><br>



</ol>


<h4><b>(4) <u>Content Design and Generation:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">







<table id="qstable" class="sortable" border="0">
<tr id="Zhu2017Automatically" class="entry">
<li>Z. Zhu, C. Hua, Y. Zou, B. Xie, and J. Zhao, "Automatically generating task-oriented api learning guide," in The Asia-Pacific Symposium, 2017, pp. 1-10.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Zhu2017Automatically','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Zhu2017Automatically','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Zhu2017Automatically" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Learning and reusing open source API libraries remain a time consuming process due to the documentation quality and the knowledge gap between API providers and users. Some researchers and API providers have found that the development tasks would narrow the knowledge gap and meet the needs of busy developers. To our knowledge, there is no existing work to generating task oriented API documents. In this paper, we propose an automatic approach to generating task oriented API learning guide. The guide is organized by a hierarchical task list. We integrate the natural language processing techniques with an evidence-based filtering pipeline in our approach. We also employ a graph-based clustering procedure to generate a three-layer task list. Furthermore, we define the normal form of the task phrases as the metadata in our approach. The approach has been implemented as a tool, APITasks. We used it to generate the API documents for four libraries. In an empirical study, we evaluate the accuracy and completeness of our approach with the manually created benchmarks. The results affirm the capability of our approach.</td></tr>
<tr id="bib_Zhu2017Automatically" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Zhu2017Automatically,
  title={Automatically Generating Task-Oriented API Learning Guide},
  author={Zhu, Zixiao and Hua, Chenyan and Zou, Yanzhen and Xie, Bing and Zhao, Junfeng},
  booktitle={The  Asia-Pacific Symposium},
  pages={1-10},
  year={2017},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Sohan2017Automated" class="entry">
<li>S. M. Sohan, C. Anslow, and F. Maurer, "Automated example oriented rest api documentation at cisco," in International Conference on Software Engineering: Software Engineering in Practice Track, 2017, pp. 213-222.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Sohan2017Automated','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Sohan2017Automated','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Sohan2017Automated" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Generating and maintaining an up-to-date API documentation is a challenging problem for evolving REST APIs. At Cisco, we've used SpyREST, an automated REST API documentation tool, via our functional tests to solve this problem with one of our APIs for a cyber security application over the past eighteen months. Using this approach, we've avoided the need for extensive manual effort by leveraging our test code to also generate a continuously updated API documentation as the API evolved. Our always-updated API documentation has helped creating a fast feedback loop between the developers and QA engineers. The findings from this paper can be used by practitioners to introduce automation to reduce the manual effort associated to their REST API documentation process. </td></tr>
<tr id="bib_Sohan2017Automated" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Sohan2017Automated,
  title={Automated example oriented REST API documentation at Cisco},
  author={Sohan, S M and Anslow, Craig and Maurer, Frank},
  booktitle={International Conference on Software Engineering: Software Engineering in Practice Track},
  pages={213-222},
  year={2017},
 keywords={API;HTTP;REST;automation;case study;documentation;test;tool;web API},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Rocha2016Automated" class="entry">
<li>A. M. Rocha and M. A. Maia, "Automated api documentation with tutorials generated from stack overflow," in Brazilian Symposium on Software Engineering, 2016, pp. 33-42.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Rocha2016Automated','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Rocha2016Automated','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Rocha2016Automated" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software reuse provides benefits during the software development and maintenance processes. The use of APIs is one of the most common ways to reuse. However, obtaining an easy-to-understand documentation is a challenge faced by developers. Several papers have proposed alternatives to make API documentation more understandable, or even more detailed. However, these studies have not taken into account the complexity of examples in order to make documentation adaptable to different levels of developer experience. In this work, we developed and evaluated four different methodologies to generate tutorials for APIs from the contents of Stack Overflow and organize them according to the complexity of understanding. The methodologies were evaluated through tutorials generated for the Swing API. A survey was conducted to evaluate eight different features of the generated tutorials. The overall outcome was positive on several characteristics, showing the feasibility of automatically generated tutorials. In addition, the adoption of features for presenting tutorial elements in order of complexity, for separating the tutorial in basic and advanced parts, for selecting posts with a tutorial nature and with didactic source code had significantly better results regarding the generation methodology. </td></tr>
<tr id="bib_Rocha2016Automated" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Rocha2016Automated,
  title={Automated API Documentation with Tutorials Generated From Stack Overflow},
  author={Rocha, Adriano M. and Maia, Marcelo A.},
  booktitle={Brazilian Symposium on Software Engineering},
  pages={33-42},
  year={2016},
 keywords={Minera&#231;227;o de Reposit&#243;rios;Redocumenta&#231;227;o de APIs;Stack Overflow},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Song2016Automatic" class="entry">
<li>M. A. J. Song, "Automatic formal specification generation of apis by mining unit tests," in ACM Symposium on Applied Computing, 2016, pp. 1542-1545.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Song2016Automatic','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Song2016Automatic','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Song2016Automatic" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Specification mining is a research field which combines the power of rigorous mathematical methods and data mining to automatically produce reliable formal specifications. In this article, we introduce MUTE to address the problem of generating a formal specification for API clients by using unit tests of the consumed library as the only input. We evaluate the proposed approach using the popular JDK 6 library and investigate how generated and handcrafted unit tests contribute to the learning process based on an extended framework developed to support automatic accuracy assessment. With precision values always above 83%, we demonstrate how both handcrafted and randomly generated unit tests can be harnessed to learn valid usage scenarios of an API. </td></tr>
<tr id="bib_Song2016Automatic" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Song2016Automatic,
  title={Automatic formal specification generation of APIs by mining unit tests},
  author={Song, Mark Alan J.},
  booktitle={ACM Symposium on Applied Computing},
  pages={1542-1545},
  year={2016},
 keywords={MUTE;specification mining;unit tests mining},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Sohan2016SpyREST" class="entry">
<li>S. M. Sohan, C. Anslow, and F. Maurer, "Spyrest: Automated restful api documentation using an http proxy server (n)," in Ieee/acm International Conference on Automated Software Engineering, 2016, pp. 271-276.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Sohan2016SpyREST','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Sohan2016SpyREST','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Sohan2016SpyREST" class="abstract noshow"><td colspan="7"><b>Abstract</b>: RESTful API documentation is expensive to produce and maintain due to the lack of reusable tools and automated solutions. Most RESTful APIs are documented manually and the API developers are responsible for keeping the documentation up to date as the API evolves making the process both costly and error-prone. In this paper we introduce a novel technique using an HTTP proxy server that can be used to automatically generate RESTful API documentation and demonstrate SpyREST, an example implementation of the proposed technique. SpyREST uses a proxy to intercept example API calls and intelligently produces API documentation for RESTful Web APIs by processing the request and response data. Using the proposed HTTP proxy server based technique, RESTful API developers can significantly reduce the cost of producing and maintaining API documentation by replacing a large manual process with an automated process. </td></tr>
<tr id="bib_Sohan2016SpyREST" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Sohan2016SpyREST,
  title={SpyREST: Automated RESTful API Documentation Using an HTTP Proxy Server (N)},
  author={Sohan, S M. and Anslow, Craig and Maurer, Frank},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={271-276},
  year={2016},
 keywords={Example based documentation;RESTful API;Web API;Documentation;Automation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Zhai2016Automatic" class="entry">
<li>J. Zhai, J. Huang, S. Ma, X. Zhang, L. Tan, J. Zhao, and F. Qin, "Automatic model generation from documentation for java api functions," pp. 380-391, 2016.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Zhai2016Automatic','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Zhai2016Automatic','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Zhai2016Automatic" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Modern software systems are becoming increasingly complex, relying on a lot of third-party library support. Library behaviors are hence an integral part of software behaviors. Analyzing them is as important as analyzing the software itself. However, analyzing libraries is highly challenging due to the lack of source code, implementation in different languages, and complex optimizations. We observe that many Java library functions provide excellent documentation, which concisely describes the functionalities of the functions. We develop a novel technique that can construct models for Java API functions by analyzing the documentation. These models are simpler implementations in Java compared to the original ones and hence easier to analyze. More importantly, they provide the same functionalities as the original functions. Our technique successfully models 326 functions from 14 widely used Java classes. We also use these models in static taint analysis on Android apps and dynamic slicing for Java programs, demonstrating the effectiveness and efficiency of our models. </td></tr>
<tr id="bib_Zhai2016Automatic" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Zhai2016Automatic,
  title={Automatic model generation from documentation for Java API functions},
  author={Zhai, Juan and Huang, Jianjun and Ma, Shiqing and Zhang, Xiangyu and Tan, Lin and Zhao, Jianhua and Qin, Feng},
  pages={380-391},
  year={2016},
 keywords={documentation analysis;environment modeling;natural language processing;auto-testing},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Verbeek2015Formal" class="entry">
<li>F. Verbeek, O. Havle, J. Schmaltz, S. Tverdyshev, H. Blasum, B. Langenstein, W. Stephan, B. Wolff, and Y. Nemouchi, "Formal api specification of the pikeos separation kernel," Lecture Notes in Computer Science, vol. 9058, pp. 375-389, 2015.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Verbeek2015Formal','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Verbeek2015Formal','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Verbeek2015Formal" class="abstract noshow"><td colspan="7"><b>Abstract</b>: PikeOS is an industrial operating system for safety and security critical applications in, for example, avionics and automotive contexts. A consortium of several European partners from industry and ac </td></tr>
<tr id="bib_Verbeek2015Formal" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Verbeek2015Formal,
  title={Formal API Specification of the PikeOS Separation Kernel},
  author={Verbeek, Freek and Havle, Oto and Schmaltz, Julien and Tverdyshev, Sergey and Blasum, Holger and Langenstein, Bruno and Stephan, Werner and Wolff, Burkhart and Nemouchi, Yakoub},
  journal={Lecture Notes in Computer Science},
  volume={9058},
  pages={375-389},
  year={2015},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Pandita2012Inferring" class="entry">
<li>R. Pandita, X. Xiao, H. Zhong, T. Xie, S. Oney, and A. Paradkar, "Inferring method specifications from natural language api descriptions," in International Conference on Software Engineering, 2012, pp. 815-825.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Pandita2012Inferring','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Pandita2012Inferring','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Pandita2012Inferring" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Application Programming Interface (API) documents are a typical way of describing legal usage of reusable software libraries, thus facilitating software reuse. However, even with such documents, developers often overlook some documents and build software systems that are inconsistent with the legal usage of those libraries. Existing software verification tools require formal specifications (such as code contracts), and therefore cannot directly verify the legal usage described in natural language text of API documents against the code using that library. However, in practice, most libraries do not come with formal specifications, thus hindering tool-based verification. To address this issue, we propose a novel approach to infer formal specifications from natural language text of API documents. Our evaluation results show that our approach achieves an average of 92% precision and 93% recall in identifying sentences that describe code contracts from more than 2500 sentences of API documents. Furthermore, our results show that our approach has an average 83% accuracy in inferring specifications from over 1600 sentences describing code contracts. </td></tr>
<tr id="bib_Pandita2012Inferring" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Pandita2012Inferring,
  title={Inferring method specifications from natural language API descriptions},
  author={Pandita, Rahul and Xiao, Xusheng and Zhong, Hao and Xie, Tao and Oney, Stephen and Paradkar, Amit},
  booktitle={International Conference on Software Engineering},
  pages={815-825},
  year={2012},
 keywords={application program interfaces;document handling;formal specification;natural language processing;program verification;software libraries;software reusability;text analysis;application programming interface documents;formal specifications},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Ahrendt2012Real" class="entry">
<li>W. Ahrendt, W. Mostowski, and G. Paganelli, "Real-time java api specifications for high coverage test generation," in International Workshop on Java Technologies for Real-Time and Embedded Systems, 2012, pp. 145-154.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Ahrendt2012Real','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Ahrendt2012Real','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Ahrendt2012Real" class="abstract noshow"><td colspan="7"><b>Abstract</b>: We present the test case generation method and tool KeY-TestGen in the context of real-time Java applications and libraries. The generated tests feature strong coverage criteria, like the Modified Condition/Decision Criterion, by construction. This is achieved by basing the test generation on formal verification techniques, namely the KeY system for Java source code verification. Moreover, we present formal specifications for the classes and methods in the real-time Java API. These specifications are used for symbolic execution when generating tests for real-time Java applications, and for oracle construction when generating tests for realtime Java library implementations. The latter application exhibited a mismatch between a commercial library implementation and the official RTSJ documentation. Even if there is a rationale behind this particular inconsistency, it demonstrates the effectiveness of our method on production code. </td></tr>
<tr id="bib_Ahrendt2012Real" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Ahrendt2012Real,
  title={Real-time Java API specifications for high coverage test generation},
  author={Ahrendt, Wolfgang and Mostowski, Wojciech and Paganelli, Gabriele},
  booktitle={International Workshop on Java Technologies for Real-Time and Embedded Systems},
  pages={145-154},
  year={2012},
 keywords={coverage;real-time Java;test generation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Toegl2012Specification" class="entry">
<li>R. Toegl, T. Winkler, M. Nauman, and T. W. Hong, "Specification and standardization of a java trusted computing api," Software Practice & Experience, vol. 42, no. 8, pp. 945-965, 2012.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Toegl2012Specification','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Toegl2012Specification','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Toegl2012Specification" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The paradigm of Trusted Computing promises a new approach to improve the security of computer systems. The core functionality, based on a hardware component known as Trusted Platform Module, is integrated into commodity hardware. However, operating system integration and application software support remains limited at present. In particular, for Java, the most widely used platform-independent computing environment, there is currently no generally accepted Trusted Computing API. In this article, we describe the design of a high-level API for Trusted Computing. We report on the current state of the Trusted Computing Group's software architecture and on previous approaches targeting Java. We derive our requirements and design goals and describe a novel API design. We report on our transparent approach to standardization in the Java Community Process. The result of this effort is the API we propose in the Java Specification Request 321. In this work, we not only present the design of this new API but also discuss implementation and testing strategies. Copyright 漿 2011 John Wiley & Sons, Ltd. </td></tr>
<tr id="bib_Toegl2012Specification" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Toegl2012Specification,
  title={Specification and Standardization of a Java Trusted Computing API},
  author={Toegl, Ronald and Winkler, Thomas and Nauman, Mohammad and Hong, Theodore W},
  journal={Software Practice & Experience},
  volume={42},
  number={8},
  pages={945-965},
  year={2012},
 keywords={trusted computing;Java;standardization},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Zhong2010Inferring" class="entry">
<li>H. Zhong, L. Zhang, T. Xie, and H. Mei, "Inferring resource specifications from natural language api documentation," in Ieee/acm International Conference on Automated Software Engineering, 2010, pp. 307-318.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Zhong2010Inferring','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Zhong2010Inferring','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Zhong2010Inferring" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Typically, software libraries provide API documentation, through which developers can learn how to use libraries correctly. However, developers may still write code inconsistent with API documentation and thus introduce bugs, as existing research shows that many developers are reluctant to carefully read API documentation. To find those bugs, researchers have proposed various detection approaches based on known specifications. To mine specifications, many approaches have been proposed, and most of them rely on existing client code. Consequently, these mining approaches would fail to mine specifications when client code is not available. In this paper, we propose an approach, called Doc2Spec, that infers resource specifications from API documentation. For our approach, we implemented a tool and conducted an evaluation on Javadocs of five libraries. The results show that our approach infers various specifications with relatively high precisions, recalls, and F-scores. We further evaluated the usefulness of inferred specifications through detecting bugs in open source projects. The results show that specifications inferred by Doc2Spec are useful to detect real bugs in existing projects. </td></tr>
<tr id="bib_Zhong2010Inferring" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Zhong2010Inferring,
  title={Inferring Resource Specifications from Natural Language API Documentation},
  author={Zhong, Hao and Zhang, Lu and Xie, Tao and Mei, Hong},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={307-318},
  year={2010},
 keywords={application program interfaces;data mining;formal specification;natural language processing;program testing;software libraries;Doc2Spec;F-scores;Javadocs;application programming interface},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Horie2009Aspect" class="entry">
<li>M. Horie and S. Chiba, "Aspect-oriented generation of the api documentation for aspectj," in The Workshop on Domain-Specific Aspect Languages, 2009, pp. 15-20.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Horie2009Aspect','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Horie2009Aspect','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Horie2009Aspect" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Through the development of a framework or a class library, writing the document on their application programming interface (API) is essential. The document on the API, which we call the API documentation, is mainly read by programmers who want to develop their applications on top of that framework or library. In this paper, we present a tool named CommentWeaver, which generates the API documentation of a framework/library written in AspectJ. CommentWeaver extracts the descriptions for the API documentation from both classes and aspects in the source files, and then it weaves them for generating the API documentation in HTML. Although ajdoc similarly generates the API documentation for AspectJ, the generated API documentation does not directly present the exact behavior of the API if it is affected by aspects. </td></tr>
<tr id="bib_Horie2009Aspect" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Horie2009Aspect,
  title={Aspect-oriented generation of the API documentation for AspectJ},
  author={Horie, Michihiro and Chiba, Shigeru},
  booktitle={The Workshop on Domain-Specific Aspect Languages},
  pages={15-20},
  year={2009},
 keywords={domain specific aspect language},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Zhong2008Inferring" class="entry">
<li>H. Zhong, L. Zhang, and H. Mei, "Inferring specifications of object oriented apis from api source code," in Software Engineering Conference, 2008. APSEC ‿08. Asia-Pacific, 2008, pp. 221-228.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Zhong2008Inferring','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Zhong2008Inferring','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Zhong2008Inferring" class="abstract noshow"><td colspan="7"><b>Abstract</b>: API libraries are becoming increasingly popular in modern software industries because these libraries provide various methods and classes for reuse. However, as pointed out by researchers, libraries are typically difficult to use. It is desirable to infer some specifications for libraries so that programmers can learn the correct usages of these libraries. In this paper, we propose an approach to infer specifications from source code of API libraries. Our approach is based on the observation that rules in object-oriented programs can be traced from basic constraints such as memory usage, file usage, and network protocol. In addition, rules of one class spread to its dependent classes through the features of object-oriented programs such as derivation, invocation relationship, and field access among methods. Based on our approach, we implemented a prototype named Java Rule Finder (JRF) to infer specifications from source code of API libraries in Java. We conducted four case studies using JRF. The result shows that JRF infers some rules correctly. We further conducted an experiment on three open source API libraries. The results show that JRF scales well with real API libraries. </td></tr>
<tr id="bib_Zhong2008Inferring" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Zhong2008Inferring,
  title={Inferring Specifications of Object Oriented APIs from API Source Code},
  author={Zhong, Hao and Zhang, Lu and Mei, Hong},
  booktitle={Software Engineering Conference, 2008. APSEC '08.  Asia-Pacific},
  pages={221-228},
  year={2008},
 keywords={DP industry;Java;application program interfaces;formal specification;object-oriented programming;software libraries;API libraries;API source code;Java Rule Finder;infer specifications},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Kurilin2006Design" class="entry">
<li>I. Kurilin, V. Safonov, J. Buford, and A. Kaplan, "Design of a reference implementation of a standard java api for instant messaging and presence," in IEEE Tenth International Symposium on Consumer Electronics, 2006, pp. 1-5.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Kurilin2006Design','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Kurilin2006Design','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Kurilin2006Design" class="abstract noshow"><td colspan="7"><b>Abstract</b>: A new standard for an instant messaging and presence (IMP) API has been developed in the Java Community. This specification defines a protocol neutral interface to such protocols as IETF SIP/SIMPLE, OMA IMPS, and IETF XMPP (Jabber). In this paper we describe the design and technical issues in developing a multi-protocol reference implementation. We compare this work with our previous implementation of a SIP/SIMPLE specific API and with the Gaim open source multiprotocol client architecture. This analysis is important for designers of consumer and mobile products that incorporate IMP functionality </td></tr>
<tr id="bib_Kurilin2006Design" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Kurilin2006Design,
  title={Design of a Reference Implementation of a Standard Java API for Instant Messaging and Presence},
  author={Kurilin, I. and Safonov, V. and Buford, J. and Kaplan, A.},
  booktitle={IEEE Tenth International Symposium on Consumer Electronics},
  pages={1-5},
  year={2006},
 keywords={multiprotocol API;instant messaging and presence},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Hakala2002Generating" class="entry">
<li>M. Hakala, K. Kai, and P. Savolainen, "Generating pattern-based web tutorials for java frameworks," in Revised Papers from the International Workshop on Scientific Engineering for Distributed Java Applications, 2002, pp. 99-110.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Hakala2002Generating','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Hakala2002Generating','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Hakala2002Generating" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Application frameworks are a popular technique to implement product-line architectures. The problem of communicating the relevant properties of a framework for application developers is studied. It is </td></tr>
<tr id="bib_Hakala2002Generating" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Hakala2002Generating,
  title={Generating Pattern-Based Web Tutorials for Java Frameworks},
  author={Hakala, Markku and Kai, Koskimies and Savolainen, Pekka},
  booktitle={Revised Papers from the International Workshop on Scientific Engineering for Distributed Java Applications},
  pages={99-110},
  year={2002},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Leslie2002Using" class="entry">
<li>D. M. Leslie, "Using javadoc and xml to produce api reference documentation," in International Conference on Computer Documentation, 2002, pp. 104-109.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Leslie2002Using','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Leslie2002Using','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Leslie2002Using" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The creation of API reference documentation and its integration into larger documentation sets present a number of challenges. This paper explores a strategy for using Javadoc, the primary mechanism for generating Java API documentation, in conjunction with an XML infrastructure, to improve the quality of API reference material and its integration into product documentation sets. </td></tr>
<tr id="bib_Leslie2002Using" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Leslie2002Using,
  title={Using Javadoc and XML to produce API reference documentation},
  author={Leslie, Donald M.},
  booktitle={International Conference on Computer Documentation},
  pages={104-109},
  year={2002},
 keywords={API documentation;HTML;Javadoc;XML;XSL stylesheets;XSLT;doclets;document transformation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Kramer1999API" class="entry">
<li>D. Kramer, "Api documentation from source code comments:a case study of javadoc," in International Conference on Documentation, Sigdoc 1999, New Orleans, Louisiana, Usa, September, 1999, pp. 147-153.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Kramer1999API','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Kramer1999API','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Kramer1999API" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This paper describes in a general way the process we went through to determine the goals, principles, audience, content and style for writing comments in source code for the Java platform at the Java Software division of Sun Microsystems. This includes how the documentation comments evolved to become the home of the Java platform API specification, and the guidelines we developed to make it practical for this document to reside in the same files as the source code. </td></tr>
<tr id="bib_Kramer1999API" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Kramer1999API,
  title={API documentation from source code comments:a case study of Javadoc},
  author={Kramer, Douglas},
  booktitle={International Conference on Documentation, Sigdoc 1999, New Orleans, Louisiana, Usa, September},
  pages={147-153},
  year={1999},
}
</pre></td></tr></table><br>


</ol>


<h4><b>(5) <u>Information Extraction and Analysis:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">







<table id="qstable" class="sortable" border="0">
<tr id="Abukwaik2017Extracting" class="entry">
<li>H. Abukwaik, M. Abujayyab, S. R. Humayoun, and D. Rombach, "Extracting conceptual interoperability constraints from api documentation using machine learning," in Ieee/acm International Conference on Software Engineering Companion, 2017, pp. 701-703.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Abukwaik2017Extracting','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Abukwaik2017Extracting','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Abukwaik2017Extracting" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Successfully using a software web-service/platform API requires satisfying its conceptual interoperability constraints that are stated within its shared documentation. However, manual and unguided analysis of text in API documents is a tedious and time consuming task. In this work, we present our empirical-based methodology of using machine learning techniques for automatically identifying conceptual interoperability constraints from natural language text. We also show some initial promising results of our research. </td></tr>
<tr id="bib_Abukwaik2017Extracting" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Abukwaik2017Extracting,
  title={Extracting Conceptual Interoperability Constraints from API Documentation Using Machine Learning},
  author={Abukwaik, Hadil and Abujayyab, Mohammed and Humayoun, Shah Rukh and Rombach, Dieter},
  booktitle={Ieee/acm International Conference on Software Engineering Companion},
  pages={701-703},
  year={2017},
 keywords={Interoperability;conceptual constraints;API documentation;empirical study;machine learning},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Uddin2017Automatic" class="entry">
<li>G. Uddin and F. Khomh, "Automatic summarization of api reviews," in IEEE/ACM International Conference on Automated Software Engineering, 2017, pp. 159-170.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Uddin2017Automatic','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Uddin2017Automatic','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Uddin2017Automatic" class="abstract noshow"><td colspan="7"><b>Abstract</b>: With the proliferation of online developer forums as informal documentation, developers often share their opinions about the APIs they use. However, given the plethora of opinions available for an API in various online developer forums, it can be challenging for a developer to make informed decisions about the APIs. While automatic summarization of opinions have been explored for other domains (e.g., cameras, cars), we found little research that investigates the benefits of summaries of public API reviews. In this paper, we present two algorithms (statistical and aspect-based) to summarize opinions about APIs. To investigate the usefulness of the techniques, we developed, Opiner, an online opinion summarization engine that presents summaries of opinions using both our proposed techniques and existing six off-the-shelf techniques. We investigated the usefulness of Opiner using two case studies, both involving professional software engineers. We found that developers were interested to use our proposed summaries much more frequently than other summaries (daily vs once a year) and that while combined with Stack Overflow, Opiner helped developers to make the right decision with more accuracy and confidence and in less time. </td></tr>
<tr id="bib_Uddin2017Automatic" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Uddin2017Automatic,
  title={Automatic summarization of API reviews},
  author={Uddin, Gias and Khomh, Foutse},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={159-170},
  year={2017},
 keywords={ieee computer society},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Uddin2017Opiner" class="entry">
<li>G. Uddin and F. Khomh, "Opiner: An opinion search and summarization engine for apis," in Ieee/acm International Conference on Automated Software Engineering, 2017, pp. 978-983.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Uddin2017Opiner','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Uddin2017Opiner','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Uddin2017Opiner" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Opinions are key determinants to many of the activities related to software development. The perceptions of developers about an API, and the choices they make about whether and how they should use it, may, to a considerable degree, be conditioned upon how other developers see and evaluate the API. Given the plethora of APIs available for a given development task and the advent of developer forums as the media to share opinions about those APIs, it can be challenging for a developer to make informed decisions about an API to support the task. We introduce Opiner, our opinion search and summarization engine for API reviews. The server side of Opiner collects and summarizes opinions about APIs by crawling online developer forums and by associating the opinions found in the forum posts to the APIs discussed in the posts. The client side of Opiner is a Website that presents different summarized viewpoints of the opinions about the APIs in an online search engine. We evaluated Opiner by asking Industrial developers to select APIs for two development tasks. We found that developers were interested to use our proposed summaries of API reviews and that while combined with Stack Overflow, Opiner helped developers to make the right decision with more accuracy and confidence. The Opiner online search engine is available at: http://opiner.polymtl.ca. A video demo is available at: https://youtu.be/XAXpfmg5Lqs. </td></tr>
<tr id="bib_Uddin2017Opiner" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Uddin2017Opiner,
  title={Opiner: An opinion search and summarization engine for APIs},
  author={Uddin, Gias and Khomh, Foutse},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={978-983},
  year={2017},
 keywords={ieee computer society},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Chatterjee2017What" class="entry">
<li>P. Chatterjee, M. A. Nishi, K. Damevski, V. Augustine, L. Pollock, and N. A. Kraft, "What information about code snippets is available in different software-related documents? an exploratory study," in IEEE International Conference on Software Analysis, Evolution and Reengineering, 2017, pp. 382-386.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Chatterjee2017What','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Chatterjee2017What','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Chatterjee2017What" class="abstract noshow"><td colspan="7"><b>Abstract</b>: A large corpora of software-related documents is available on the Web, and these documents offer the unique opportunity to learn from what developers are saying or asking about the code snippets that they are discussing. For example, the natural language in a bug report provides information about what is not functioning properly in a particular code snippet. Previous research has mined information about code snippets from bug reports, emails, and Q&A forums. This paper describes an exploratory study into the kinds of information that is embedded in different software-related documents. The goal of the study is to gain insight into the potential value and difficulty of mining the natural language text associated with the code snippets found in a variety of software-related documents, including blog posts, API documentation, code reviews, and public chats. </td></tr>
<tr id="bib_Chatterjee2017What" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Chatterjee2017What,
  title={What information about code snippets is available in different software-related documents? An exploratory study},
  author={Chatterjee, Preetha and Nishi, Manziba Akanda and Damevski, Kostadin and Augustine, Vinay and Pollock, Lori and Kraft, Nicholas A.},
  booktitle={IEEE  International Conference on Software Analysis, Evolution and Reengineering},
  pages={382-386},
  year={2017},
 keywords={ieee computer society},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Phan2017Statistical" class="entry">
<li>H. Phan, H. A. Nguyen, T. N. Nguyen, and H. Rajan, "Statistical learning for inference between implementations and documentation," in Ieee/acm International Conference on Software Engineering: New Ideas and Emerging Technologies Results Track, 2017, pp. 27-30.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Phan2017Statistical','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Phan2017Statistical','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Phan2017Statistical" class="abstract noshow"><td colspan="7"><b>Abstract</b>: API documentation is useful for developers to better understand how tocorrectly use the libraries. However, not all libraries provide gooddocumentation on API usages. To provide better documentation, existingtechniques have been proposed including program analysis-based anddata mining-based approaches. In this work, instead of mining, we aimto generate behavioral exception documentation for any given code. Wetreat the problem of automatically generating documentation from anovel perspective: statistical machine translation (SMT). We considerthe documentation and source code for an API method as the twoabstraction levels of the same intention. We use SMT to translatedocumentation from source code and vice versa. Our preliminary resultsshow that the direction of statistical learning for inference betweenimplementations and documentation is very promising. </td></tr>
<tr id="bib_Phan2017Statistical" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Phan2017Statistical,
  title={Statistical Learning for Inference between Implementations and Documentation},
  author={Phan, Hung and Nguyen, Hoan Anh and Nguyen, Tien N. and Rajan, Hridesh},
  booktitle={Ieee/acm  International Conference on Software Engineering: New Ideas and Emerging Technologies Results Track},
  pages={27-30},
  year={2017},
 keywords={API documentation generation;statistical machine translation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Wang2017Mining" class="entry">
<li>S. Wang, W. Dou, C. Gao, J. Wei, and T. Huang, "Mining api type specifications for javascript," in Asia-Pacific Software Engineering Conference, 2017, pp. 368-377.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Wang2017Mining','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Wang2017Mining','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Wang2017Mining" class="abstract noshow"><td colspan="7"><b>Abstract</b>: API specifications play an important role in software development. However, API specifications are often not well documented, especially for JavaScript. Many JavaScript API specifications lack of precise type information for API parameters and return values. In this paper, we propose a static approach for mining JavaScript type specifications automatically. We gather the usage information of return values and parameters statically, and infer types of return values based their usages, by identifying a known type which they are used most likely to be, and infer parameters by identifying the most used parameters. We evaluate the approach on the homepages of Alexa top 1000 websites, the experimental results show that our approach can gain high precision. Our case study on jQuery shows that our approach gains high precision and reasonable recall on jQuery, and we can use our inferred API type specifications to detect 2 jQuery misusage errors in real-world web sites, and 1 missing type error in jQuery documentations. </td></tr>
<tr id="bib_Wang2017Mining" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Wang2017Mining,
  title={Mining API Type Specifications for JavaScript},
  author={Wang, Shuai and Dou, Wensheng and Gao, Chushu and Wei, Jun and Huang, Tao},
  booktitle={Asia-Pacific Software Engineering Conference},
  pages={368-377},
  year={2017},
 keywords={ieee computer society},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Ellmann2017On" class="entry">
<li>M. Ellmann, "On the similarity of software development documentation," in ESEC/FSE'17: Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering Proceedings, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Ellmann2017On','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Ellmann2017On','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Ellmann2017On" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers spent 20% of their time on information seeking on Stack Overflow, YouTube or an API reference documentation. Software developers can search within Stack Overflow for duplicates or similar posts. They can also take a look on software development documentations that have similar and additional information included as a Stack Overflow post or a development screencast in order to get new inspirations on how to solve their current development problem. The linkage of same and different types of software development documentation might safe time to evolve new software solutions and might increase the productivity of the developer’s work day. In this paper we will discuss our approach to get a broader understanding of different similarity types (exact, similar and maybe) within and between software documentation as well as an understanding of how different software documentations can be extended. </td></tr>
<tr id="bib_Ellmann2017On" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Ellmann2017On,
  title={On the Similarity of Software Development Documentation},
  author={Ellmann, Mathias},
  booktitle={ESEC/FSE'17: Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering Proceedings},
  year={2017},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Wu2017Linking" class="entry">
<li>N. Wu, D. Hou, and Q. Liu, "Linking usage tutorials into api client code," in IEEE/ACM International Workshop on Crowdsourcing in Software Engineering, 2017, pp. 22-28.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Wu2017Linking','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Wu2017Linking','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Wu2017Linking" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Traceability links between software artifacts have important applications in the development process. This paper concerns a special case of traceability recovery, i.e., the automated integration of API usage tutorials with the API client code. Our solution involves partitioning the client code into multiple semantic groups/snippets and linking each snippet to the best matching tutorials. Evaluation using benchmarks created for two popular APIs reveals that our solution can find the expected tutorial links at the average rank of 1.6 and 1.4 in the top ranked results, for the two API's, respectively, and with good average precision and recall. We also evaluate the impact of both method partitioning and JavaDoc query expansion on tutorial linking performance. Lastly, we conduct a formative user study to pinpoint the scenarios where our solution actually helps a software developer. We conclude that it is a promising approach to speeding up the maintenance of API client code. </td></tr>
<tr id="bib_Wu2017Linking" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Wu2017Linking,
  title={Linking Usage Tutorials into API Client Code},
  author={Wu, Naihao and Hou, Daqing and Liu, Qingkun},
  booktitle={Ieee/acm  International Workshop on Crowdsourcing in Software Engineering},
  pages={22-28},
  year={2017},
 keywords={Java;API;Documentation;Traceability;Information Retrieval;Vector Space Model;Abstract Syntax Tree},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Aversano2017Analysis" class="entry">
<li>L. Aversano, D. Guardabascio, and M. Tortorella, "Analysis of the documentation of erp software projects," Procedia Computer Science, vol. 121, pp. 423-430, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Aversano2017Analysis','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Aversano2017Analysis','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Aversano2017Analysis" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software documentation is a basic component of the software development process and it is very important in all the phases of a software system life cycle. It is plays a very important role from the point of view of both the software engineer and user. Software documentation usually includes textual documentation required by the Software engineering standards, API documentation, Wiki pages and source code comments. Surveys and studies indicate that the documentation is not always available and, if available, only partially addresses the developers鈿 needs, as it is often wrong, incomplete, out-of-date and ambiguous. In the context of ERP 鈿 Enterprise Resource Planning, the relevance of the software documentation is even more important due to the complexity of such a kind of software systems and the strategic role they have within operative organizations. This paper focuses on the quality assessment of the documentation of ERP open source systems with the aim of understanding if they include high quality documentation for adequately support anyone want to adopt them and/or executing maintenance activities. Specifically, a quality model is defined and its application to three Open source software system is performed. </td></tr>
<tr id="bib_Aversano2017Analysis" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Aversano2017Analysis,
  title={Analysis of the Documentation of ERP Software Projects},
  author={Aversano, Lerina and Guardabascio, Daniela and Tortorella, Maria},
  journal={Procedia Computer Science},
  volume={121},
  pages={423-430},
  year={2017},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Abukwaik2016Towards" class="entry">
<li>H. Abukwaik, M. Abujayyab, and D. Rombach, "Towards seamless analysis of software interoperability: Automatic identification of conceptual constraints in api documentation," in European Conference on Software Architecture, 2016, pp. 67-83.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Abukwaik2016Towards','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Abukwaik2016Towards','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Abukwaik2016Towards" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Building successful and meaningful interoperation with external software APIs requires satisfying their conceptual interoperability constraints. These constraints, which we call the COINs, include str </td></tr>
<tr id="bib_Abukwaik2016Towards" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Abukwaik2016Towards,
  title={Towards Seamless Analysis of Software Interoperability: Automatic Identification of Conceptual Constraints in API Documentation},
  author={Abukwaik, Hadil and Abujayyab, Mohammed and Rombach, Dieter},
  booktitle={European Conference on Software Architecture},
  pages={67-83},
  year={2016},
 keywords={Interoperability analysis;Conceptual constraints;Black-box interoperation;API documentation;Empirical study;Machine learning},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Saied2015An" class="entry">
<li>M. A. Saied, H. Sahraoui, and B. Dufour, "An observational study on api usage constraints and their documentation," in IEEE International Conference on Software Analysis, Evolution and Reengineering, 2015, pp. 33-42.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Saied2015An','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Saied2015An','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Saied2015An" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Nowadays, APIs represent the most common reuse form when developing software. However, the reuse benefits depend greatly on the ability of client application developers to use correctly the APIs. In this paper, we present an observational study on the API usage constraints and their documentation. To conduct the study on a large number of APIs, we implemented and validated strategies to automatically detect four types of usage constraints in existing APIs. We observed that some of the constraint types are frequent and that for three types, they are not documented in general. Surprisingly, the absence of documentation is, in general, specific to the constraints and not due to the non documenting habits of developers. </td></tr>
<tr id="bib_Saied2015An" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Saied2015An,
  title={An observational study on API usage constraints and their documentation},
  author={Saied, Mohamed Aymen and Sahraoui, Houari and Dufour, Bruno},
  booktitle={IEEE  International Conference on Software Analysis, Evolution and Reengineering},
  pages={33-42},
  year={2015},
 keywords={ieee computer society},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Vidal2015Semantic" class="entry">
<li>J. C. Vidal, T. Rabelo, and M. Lama, "Semantic description of the experience api specification," in IEEE International Conference on Advanced Learning Technologies, 2015, pp. 268-269.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Vidal2015Semantic','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Vidal2015Semantic','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Vidal2015Semantic" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Capturing and storing learners' data is the first step to implement a learning analytics architecture. The Experience API (xAPI) specification is a de facto standard that describes (i) a REST-based API to store and retrieve the learners' activity data, and (ii) an RDF-based data model where the restrictions among data are specified in natural language. In this paper, we present an ontology that formally represents both the data model and the restrictions of the xAPI specification, facilitating the conformance testing of the data coming from the learning management system to guarantee the compliance with the specification. </td></tr>
<tr id="bib_Vidal2015Semantic" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Vidal2015Semantic,
  title={Semantic Description of the Experience API Specification},
  author={Vidal, Juan C. and Rabelo, Thomas and Lama, Manuel},
  booktitle={IEEE  International Conference on Advanced Learning Technologies},
  pages={268-269},
  year={2015},
 keywords={Conformance testing;Experience API;Ontologies;Learning analytics},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Souza2014On" class="entry">
<li>L. B. L. D. Souza, E. C. Campos, and M. D. A. Maia, "On the extraction of cookbooks for apis from the crowd knowledge," in Software Engineering, 2014, pp. 21-30.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Souza2014On','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Souza2014On','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Souza2014On" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Developers of reusable software elements, such as libraries, usually have the responsibility to provide comprehensive and high quality documentation to enable effective software reuse. The effective reuse of libraries depends upon the quality of the API (Application Program Interface) documentation. Well established libraries typically have comprehensive API documentation, for example in Javadocs. However, they typically lack examples and explanations, which makes the effective reuse of the library difficult. StackOverflow.com (SO) is a Question and Answer service directed to issues related to software development. On SO, developers post questions related to a programming topic and other members of the SO community can provide answers to help them solving their problems. Despite the increasing adoption of SO, the information related to a particular topic is spread across the website. Thus, SO still lacks organization of its crowd knowledge. In this paper, we present an automatic approach that organizes the information available on SO in order to build cookbooks (recipe-oriented books) for APIs. The cookbooks are meant to be used through an exploration process (browsing). In order to evaluate the proposed approach, we have generated cookbooks for three APIs widely used by the software development community: SWT, STL and LINQ. Desired properties that cookbooks must meet were identified and a study was conducted to assess to what extent the generated cookbook meet those properties. </td></tr>
<tr id="bib_Souza2014On" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Souza2014On,
  title={On the Extraction of Cookbooks for APIs from the Crowd Knowledge},
  author={Souza, Lucas B. L. De and Campos, Eduardo C. and Maia, Marcelo De A.},
  booktitle={Software Engineering},
  pages={21-30},
  year={2014},
 keywords={APIs documentation;Q&A services;crowd knowledge},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Dai2013Finding" class="entry">
<li>Z. Dai, X. Mao, L. Chen, Y. Lei, and Y. Zhang, "Finding related events for specification mining," in IEEE International Symposium on Software Reliability Engineering Workshops, 2013, pp. 1-2.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Dai2013Finding','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Dai2013Finding','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Dai2013Finding" class="abstract noshow"><td colspan="7"><b>Abstract</b>: In contemporary software development practice, programmers reuse components by invoking their APIs to construct large systems. These APIs often involve constraints on the temporal order of method calls. For the example of the file usage, a programmer should first open a file, then read and/or write its content, and at last close it. Trying to read a closed file will cause exceptions to be thrown. Such constraints are often represented as a finite state machine (FSM) with a set of related events (typically method calls) as its alphabet. A set of events are related if interactions among them possibly obey some meaningful temporal specifications. In recent years, various specification mining techniques have been developed to automatically mine API specifications from API client programs [1]. A typical API specification miner conceptually has three steps. First, it decide which events are related. Second, different interactions among related events (which are sub-traces and sample strings of the specification FSM) are extracted either from source code of client programs or from their execution traces. Third, extracted interactions are passed to customized or off-the-shelf FSM learners which generalize these sample sub-traces to recover the specification FSM. </td></tr>
<tr id="bib_Dai2013Finding" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Dai2013Finding,
  title={Finding related events for specification mining},
  author={Dai, Ziying and Mao, Xiaoguang and Chen, Liqian and Lei, Yan and Zhang, Yi},
  booktitle={IEEE International Symposium on Software Reliability Engineering Workshops},
  pages={1-2},
  year={2013},
 keywords={Related events;Specification mining;Static analysis;Component interfaces},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Maalej2013Patterns" class="entry">
<li>W. Maalej and M. P. Robillard, "Patterns of knowledge in api reference documentation," IEEE Transactions on Software Engineering, vol. 39, no. 9, pp. 1264-1282, 2013.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Maalej2013Patterns','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Maalej2013Patterns','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Maalej2013Patterns" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Reading reference documentation is an important part of programming with application programming interfaces (APIs). Reference documentation complements the API by providing information not obvious from the API syntax. To improve the quality of reference documentation and the efficiency with which the relevant information it contains can be accessed, we must first understand its content. We report on a study of the nature and organization of knowledge contained in the reference documentation of the hundreds of APIs provided as a part of two major technology platforms: Java SDK 6 and .NET 4.0. Our study involved the development of a taxonomy of knowledge types based on grounded methods and independent empirical validation. Seventeen trained coders used the taxonomy to rate a total of 5,574 randomly sampled documentation units to assess the knowledge they contain. Our results provide a comprehensive perspective on the patterns of knowledge in API documentation: observations about the types of knowledge it contains and how this knowledge is distributed throughout the documentation. The taxonomy and patterns of knowledge we present in this paper can be used to help practitioners evaluate the content of their API documentation, better organize their documentation, and limit the amount of low-value content. They also provide a vocabulary that can help structure and facilitate discussions about the content of APIs. </td></tr>
<tr id="bib_Maalej2013Patterns" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Maalej2013Patterns,
  title={Patterns of Knowledge in API Reference Documentation},
  author={Maalej, Walid and Robillard, Martin P.},
  journal={IEEE Transactions on Software Engineering},
  volume={39},
  number={9},
  pages={1264-1282},
  year={2013},
 keywords={NET;API documentation;software documentation;empirical study;content analysis;grounded method;data mining;pattern mining;Java},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Sillito2013What" class="entry">
<li>J. Sillito, F. Maurer, S. M. Nasehi, and C. Burns, "What makes a good code example?: A study of programming Q&A in stackoverflow," in IEEE International Conference on Software Maintenance, 2013, pp. 25-34.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Sillito2013What','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Sillito2013What','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Sillito2013What" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Programmers learning how to use an API or a programming language often rely on code examples to support their learning activities. However, what makes for an effective ode example remains an open question. Finding the haracteristics of the effective examples is essential in improving the appropriateness of these learning aids. To help answer this question we have onducted a qualitative analysis of the questions and answers posted to a programming Q&A web site called StackOverflow. On StackOverflow answers can be voted on, indicating which answers were found helpful by users of the site. By analyzing these well-received answers we identified haracteristics of effective examples. We found that the explanations acompanying examples are as important as the examples themselves. Our findings have implications for the way the API documentation and example set should be developed and evolved as well as the design of the tools assisting the development of these materials. </td></tr>
<tr id="bib_Sillito2013What" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Sillito2013What,
  title={What makes a good code example?: A study of programming Q&A in StackOverflow},
  author={Sillito, Jonathan and Maurer, Frank and Nasehi, Seyed Mehdi and Burns, Chris},
  booktitle={IEEE International Conference on Software Maintenance},
  pages={25-34},
  year={2013},
 keywords={social learning;code example;documentation;API},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Monperrus2012What" class="entry">
<li>M. Monperrus, E. Tekes, E. Tekes, and M. Mezini, "What should developers be aware of? an empirical study on the directives of api documentation," Empirical Software Engineering, vol. 17, no. 6, pp. 703-737, 2012.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Monperrus2012What','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Monperrus2012What','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Monperrus2012What" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Application Programming Interfaces (API) are exposed to developers in order to reuse software libraries. API directives are natural-language statements in API documentation that make developers aware of constraints and guidelines related to the usage of an API. This paper presents the design and the results of an empirical study on the directives of API documentation of object-oriented libraries. Its main contribution is to propose and extensively discuss a taxonomy of 23 kinds of API directives. </td></tr>
<tr id="bib_Monperrus2012What" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Monperrus2012What,
  title={What should developers be aware of? An empirical study on the directives of API documentation},
  author={Monperrus, Martin and Tekes, Elif and Tekes, Elif and Mezini, Mira},
  journal={Empirical Software Engineering},
  volume={17},
  number={6},
  pages={703-737},
  year={2012},
 keywords={Agile deployment;Improving agile development;Success factors for agile deployment;Software process improvement (SPI},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Jung2010Specifications" class="entry">
<li>S. D. Jung, T. O. Kim, S. S. Lee, K. S. Han, H. S. Oh, and H. K. Choi, "Specifications of apis for exchanging information based on its dedicated communication," in International Conference on Advanced Communication Technology, 2010, pp. 1498-1502.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Jung2010Specifications','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Jung2010Specifications','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Jung2010Specifications" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Conversion technology between IT(Information Technology) and automotive technics creates the new industry of ITS (Intelligent Transport systems) and the new paradigm in electronics, communication and traffic fields. Specially, Vehicular communication in ITS field is one of the most important technologies necessary to connect among driver, vehicle and provider to provide quality services. Solutions for vehicular communication based on IEEE 802.11 are described in IEEE 802.11p. IEEE 802.11p WAVE (Wireless Access in the Vehicular Environment) defines amendments to IEEE 802.11 that are necessary to support ITS applications. In Korea, V2V (Vehicle-to-Vehicle) and V2I (Vehicle-to-Infrastructure) communication systems called VMC (Vehicle Multi-hop Communication) are being developed by the Electronics and Telecommunications Research Institute. In this paper, we define the API(Application Protocol Interface) and communication sequence to provide the quality services about the reliability data exchange based on VMC. </td></tr>
<tr id="bib_Jung2010Specifications" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Jung2010Specifications,
  title={Specifications of APIs for exchanging information based on ITS dedicated communication},
  author={Jung, Sung Dae and Kim, Tae Oh and Lee, Sang Sun and Han, Kyeong Soo and Oh, Hyun Seo and Choi, Hyun Kyun},
  booktitle={International Conference on Advanced Communication Technology},
  pages={1498-1502},
  year={2010},
 keywords={API;ITS;V2V/V2I;VMC;WAYE},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Myers2010Studying" class="entry">
<li>B. A. Myers, S. Y. Jeong, Y. Xie, J. Beaton, J. Stylos, R. Ehret, J. Karstens, D. K. Busse, and D. K. Busse, "Studying the documentation of an api for enterprise service-oriented architecture," Journal of Organizational & End User Computing, vol. 22, no. 1, pp. 23-51, 2010.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Myers2010Studying','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Myers2010Studying','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Myers2010Studying" class="abstract noshow"><td colspan="7"><b>Abstract</b>: All software today is written using application programming interfaces APIs. We performed a user study of the online documentation of a large and complex API for Enterprise Service-Oriented Architecture eSOA, which identified many issues and recommendations for making API documentation easier to use. eSOA is an appropriate testbed because the target users include high-level business experts who do not have significant programming expertise and thus can be classified as "end-user developers." Our study showed that the participants' background influenced how they navigated the documentation. Lack of familiarity with business terminology was a barrier for developers without business application experience. Both groups avoided areas of the documentation that had an inconsistent visual design. A new design for the documentation that supports flexible navigation strategies seems to be required to support the wide range of users for eSOA. This paper summarizes our study and provides recommendations for future documentation for APIs. </td></tr>
<tr id="bib_Myers2010Studying" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Myers2010Studying,
  title={Studying the Documentation of an API for Enterprise Service-Oriented Architecture},
  author={Myers, Brad A. and Jeong, Sae Young and Xie, Yingyu and Beaton, Jack and Stylos, Jeff and Ehret, Ralf and Karstens, Jan and Busse, Daniela K. and Busse, Daniela K.},
  journal={Journal of Organizational & End User Computing},
  volume={22},
  number={1},
  pages={23-51},
  year={2010},
 keywords={API Design;Business Solution Architects;Documentation;Natural Programming;Service-Oriented Architecture;Usability;Web Services},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Horie2010Tool" class="entry">
<li>M. Horie and S. Chiba, "Tool support for crosscutting concerns of api documentation," in International Conference on Aspect-Oriented Software Development, 2010, pp. 97-108.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Horie2010Tool','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Horie2010Tool','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Horie2010Tool" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Writing detailed API (Application Programming Interface) documentation is a significant task for developing a good class library or framework. However, existing documentation tools such as Javadoc provide only limited support and thus the description written by programmers for API documentation often contains scattering text. Occasionally, it also contains tangling text. This paper presents that this problem is due to crosscutting concerns of API documentation. Then it proposes our new tool named Comment-Weaver, which provides several mechanisms for modularly describing API documentation of class libraries or frameworks written in Java or AspectJ. It is an extended Javadoc tool and it provides several new tags for controlling how the text manually written by the programmers is scattering and appended to other entries or how it is moved from the original entry to another entry to be tangling. Finally this paper evaluates CommentWeaver by using three class libraries and frameworks: Javassist, the Java standard library, and Eclipse. It showed that CommentWeaver resolves the problems of scattering or tangling text and it adequately reduces the amount of description written by programmers for API documentation. </td></tr>
<tr id="bib_Horie2010Tool" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Horie2010Tool,
  title={Tool support for crosscutting concerns of API documentation},
  author={Horie, Michihiro and Chiba, Shigeru},
  booktitle={International Conference on Aspect-Oriented Software Development},
  pages={97-108},
  year={2010},
 keywords={API documentation;aspect-oriented programming;domain-specific language},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Eisenberg2010Using" class="entry">
<li>D. S. Eisenberg, J. Stylos, A. Faulring, and B. A. Myers, "Using association metrics to help users navigate api documentation," in Visual Languages and Human-Centric Computing, 2010, pp. 23-30.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Eisenberg2010Using','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Eisenberg2010Using','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Eisenberg2010Using" class="abstract noshow"><td colspan="7"><b>Abstract</b>: In the past decade there has been spectacular growth in the number and size of third-party libraries, frameworks, toolkits and other Application Programming Interfaces (APIs) available to modern software developers. However, the time-saving advantages of code re-use are commonly hampered by the difficulty in finding the correct methods for a given task among the thousands of irrelevant ones. We have developed a tool called Apatite that helps address this issue by letting programmers browse APIs by viewing associations between their components. Apatite indicates which items of an API are popular in different contexts and allows browsing by initially selecting verbs (methods and actions) in addition to classes and packages. The associations are calculated by leveraging existing search engine data and source code, and verbs are identified by parsing the documentation descriptions. Apatite is available on the web and is being used by developers worldwide on a regular basis. </td></tr>
<tr id="bib_Eisenberg2010Using" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Eisenberg2010Using,
  title={Using Association Metrics to Help Users Navigate API Documentation},
  author={Eisenberg, Daniel S. and Stylos, Jeffrey and Faulring, Andrew and Myers, Brad A.},
  booktitle={Visual Languages and Human-Centric Computing},
  pages={23-30},
  year={2010},
 keywords={Web applications;API Documentation;Search tool;Browsing;Visualizations},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Dekel2009Reading" class="entry">
<li>U. Dekel and J. D. Herbsleb, "Reading the documentation of invoked api functions in program comprehension," pp. 168-177, 2009.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Dekel2009Reading','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Dekel2009Reading','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Dekel2009Reading" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Comprehending an unfamiliar code fragment requires an awareness of explicit usage directives that may be present in the documentation of some invoked functions. Since it is not practical for developers to thoroughly investigate every call, directives may be missed and errors may occur. We previously reported on a tool called eMoose, which highlights calls to methods with associated directives, and on a controlled comparative lab study in which eMoose users were more successful at fixing bugs in given code fragments. In this paper we attempt to shed light on the factors behind these differences with a detailed analysis of videos from the study. We argue that information foraging theory may explain the subjects' reading choices and the impact of our tool. We also suggest ways to structure documentation to increase the prospects of knowledge acquisition. </td></tr>
<tr id="bib_Dekel2009Reading" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Dekel2009Reading,
  title={Reading the documentation of invoked API functions in program comprehension},
  author={Dekel, Uri and Herbsleb, James D.},
  pages={168-177},
  year={2009},
 keywords={application program interfaces;knowledge acquisition;program debugging;software maintenance;application programming interfaces;information foraging theory;knowledge acquisition;program comprehension;software maintenance;Application software},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Bottomley2005What" class="entry">
<li>C. Bottomley, "What part writer? what part programmer? a survey of practices and knowledge used in programmer writing," in Professional Communication Conference, 2005. IPCC 2005. Proceedings. International, 2005, pp. 802-812.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Bottomley2005What','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Bottomley2005What','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Bottomley2005What" class="abstract noshow"><td colspan="7"><b>Abstract</b>: There are few resources geared to technical writers working on documentation for software developers. This paper presents the results of online surveys and telephone interviews that cover the experience, technical knowledge, and practices of technical writers in this area, with a large percentage of respondents who are Microsoft employees. Respondents value strong writing skills and the ability to learn quickly and continuously, with the amount and type of knowledge needed being specific to the subject area and audience for their work. </td></tr>
<tr id="bib_Bottomley2005What" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Bottomley2005What,
  title={What part writer? What part programmer? A survey of practices and knowledge used in programmer writing},
  author={Bottomley, C.},
  booktitle={Professional Communication Conference, 2005. IPCC 2005. Proceedings. International},
  pages={802-812},
  year={2005},
 keywords={application program interfaces;software engineering;system documentation;API documentation;Microsoft employees;SDK documentation;programmer writing;software developer documentation;technical knowledge;technical writing},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Nykaza2002What" class="entry">
<li>J. Nykaza, R. Messinger, F. Boehme, C. L. Norman, M. Mace, and M. Gordon, "What programmers really want:results of a needs assessment for sdk documentation," in International Conference on Documentation, Sigdoc 2002, Toronto, Ontario, Canada, October, 2002, pp. 133-141.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Nykaza2002What','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Nykaza2002What','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Nykaza2002What" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This paper steps the reader through a needs assessment of programmers that was conducted by instructional designers. The assessment's purpose was to identify what learning support programmers need and want to successfully use a new software development kit (SDK). The paper includes the challenges the researchers encountered, the questions asked and the responses, the types of individuals interviewed, and the conclusions reached from the research. Recommendations also are presented. Those responsible with developing documentation, training, and other learning support systems for programmers may find this assessment helpful. Marketing, product development and customer support people may also find value in learning more about the needs of this unique audience. </td></tr>
<tr id="bib_Nykaza2002What" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Nykaza2002What,
  title={What programmers really want:results of a needs assessment for SDK documentation},
  author={Nykaza, Janet and Messinger, Rhonda and Boehme, Fran and Norman, Cherie L. and Mace, Matthew and Gordon, Manuel},
  booktitle={International Conference on Documentation, Sigdoc 2002, Toronto, Ontario, Canada, October},
  pages={133-141},
  year={2002},
}
</pre></td></tr></table><br>



</ol>


<h4><b>(6) <u>Reference and Fragment Recommendation:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">












<table id="qstable" class="sortable" border="0">
<tr id="Jiang2017An" class="entry">
<li>H. Jiang, J. Zhang, Z. Ren, and T. Zhang, "An unsupervised approach for discovering relevant tutorial fragments for apis," in Ieee/acm International Conference on Software Engineering, 2017, pp. 38-48.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Jiang2017An','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Jiang2017An','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Jiang2017An" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Developers increasingly rely on API tutorials to facilitate software development. However, it remains a challenging task for them to discover relevant API tutorial fragments explaining unfamiliar APIs. Existing supervised approaches suffer from the heavy burden of manually preparing corpus-specific annotated data and features. In this study, we propose a novel unsupervised approach, namely Fragment Recommender for APIs with PageRank and Topic model (FRAPT). FRAPT can well address two main challenges lying in the task and effectively determine relevant tutorial fragments for APIs. In FRAPT, a Fragment Parser is proposed to identify APIs in tutorial fragments and replace ambiguous pronouns and variables with related ontologies and API names, so as to address the pronoun and variable resolution challenge. Then, a Fragment Filter employs a set of non-explanatory detection rules to remove non-explanatory fragments, thus address the non-explanatory fragment identification challenge. Finally, two correlation scores are achieved and aggregated to determine relevant fragments for APIs, by applying both topic model and PageRank algorithm to the retained fragments. Extensive experiments over two publicly open tutorial corpora show that, FRAPT improves the state-of-the-art approach by 8.77% and 12.32% respectively in terms of F-Measure. The effectiveness of key components of FRAPT is also validated. </td></tr>
<tr id="bib_Jiang2017An" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Jiang2017An,
  title={An Unsupervised Approach for Discovering Relevant Tutorial Fragments for APIs},
  author={Jiang, He and Zhang, Jingxuan and Ren, Zhilei and Zhang, Tao},
  booktitle={Ieee/acm  International Conference on Software Engineering},
  pages={38-48},
  year={2017},
 keywords={Application Programming Interface;PageRank Algorithm;Topic Model;Unsupervised Approaches},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Jiang2016A" class="entry">
<li>H. Jiang, J. Zhang, X. Li, Z. Ren, and D. Lo, "A more accurate model for finding tutorial segments explaining apis," in IEEE International Conference on Software Analysis, Evolution, and Reengineering, 2016, pp. 157-167.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Jiang2016A','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Jiang2016A','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Jiang2016A" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Developers prefer to utilize third-party libraries when they implement some functionalities and Application Programming Interfaces (APIs) are frequently used by them. Facing an unfamiliar API, developers tend to consult tutorials as learning resources. Unfortunately, the segments explaining a specific API scatter across tutorials. Hence, it remains a challenging issue to find the relevant segments. In this study, we propose a more accurate model to find the exact tutorial fragments explaining APIs. This new model consists of a text classifier with domain specific features. More specifically, we discover two important indicators to complement traditional text based features, namely co-occurrence APIs and knowledge based API extensions. In addition, we incorporate Word2Vec, a semantic similarity metric to enhance the new model. Extensive experiments over two publicly available tutorial datasets show that our new model could find up to 90% fragments explaining APIs and improve the state-of-the-art model by up to 30% in terms of F-measure. </td></tr>
<tr id="bib_Jiang2016A" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Jiang2016A,
  title={A More Accurate Model for Finding Tutorial Segments Explaining APIs},
  author={Jiang, He and Zhang, Jingxuan and Li, Xiaochen and Ren, Zhilei and Lo, David},
  booktitle={IEEE  International Conference on Software Analysis, Evolution, and Reengineering},
  pages={157-167},
  year={2016},
 keywords={Feature Construction;Application Programming Interface;Text Classification},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Robillard2015Recommending" class="entry">
<li>M. P. Robillard and Y. B. Chhetri, "Recommending reference api documentation," Empirical Software Engineering, vol. 20, no. 6, pp. 1-29, 2015.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Robillard2015Recommending','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Robillard2015Recommending','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Robillard2015Recommending" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Reference documentation is an important source of information on API usage. However, information useful to programmers can be buried in irrelevant text, or attached to a non-intuitive API element, making it difficult to discover. We propose to detect and recommend fragments of API documentation potentially important to a programmer who has already decided to use a certain API element. We categorize text fragments in API documentation based on whether they contain information that is indispensable , valuable , or neither. From the fragments that contain knowledge worthy of recommendation, we extract word patterns, and use these patterns to automatically find new fragments that contain similar knowledge in unseen documentation. We implemented our technique in a tool, Krec, that supports both information filtering and discovery. In an evaluation study with randomly-sampled method definitions from ten open source systems, we found that with a training set derived from about 1000 documentation units, we could issue recommendations with 90 % precision and 69 % recall. In a study involving ten independent assessors, indispensable knowledge items recommended for API types were judged useful 57 % of the time and potentially useful an additional 30 % of the time. </td></tr>
<tr id="bib_Robillard2015Recommending" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Robillard2015Recommending,
  title={Recommending reference API documentation},
  author={Robillard, Martin P. and Chhetri, Yam B.},
  journal={Empirical Software Engineering},
  volume={20},
  number={6},
  pages={1-29},
  year={2015},
 keywords={Application programming interfaces;API documentation;Text classification;Natural language processing;Recommendation systems},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Dekel2009Improving" class="entry">
<li>U. Dekel and J. D. Herbsleb, "Improving api documentation usability with knowledge pushing," in IEEE International Conference on Software Engineering, 2009, pp. 320-330.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Dekel2009Improving','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Dekel2009Improving','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Dekel2009Improving" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The documentation of API functions typically conveys detailed specifications for the benefit of interested readers. In some cases, however, it also contains usage directives, such as rules or caveats, of which authors of invoking code must be made aware to prevent errors and inefficiencies. There is a risk that these directives may be ldquolostrdquo within the verbose text, or that the text would not be read because there are so many invoked functions. To address these concerns for Java, an Eclipse plug-in named eMoose decorates method invocations whose targets have associated directives. Our goal is to lead readers to investigate further, which we aid by highlighting the tagged directives in the JavaDoc hover. We present a lab study that demonstrates the directive awareness problem in traditional documentation use and the potential benefits of our approach. </td></tr>
<tr id="bib_Dekel2009Improving" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Dekel2009Improving,
  title={Improving API documentation usability with knowledge pushing},
  author={Dekel, Uri and Herbsleb, James D.},
  booktitle={IEEE  International Conference on Software Engineering},
  pages={320-330},
  year={2009},
 keywords={Java;application program interfaces;system documentation;API documentation usability;Eclipse plug-in;Java;eMoose decorates method;knowledge pushing;usage directive;Application software},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Stylos2009Improving" class="entry">
<li>J. Stylos, A. Faulring, Z. Yang, and B. A. Myers, "Improving api documentation using api usage information," in IEEE Symposium on Visual Languages and Human-Centric Computing, 2009, pp. 119- 126.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Stylos2009Improving','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Stylos2009Improving','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Stylos2009Improving" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Jadeite is a new Javadoc-like API documentation system that takes advantage of multiple users' aggregate experience to reduce difficulties that programmers have learning new APIs. Previous studies have shown that programmers often guessed that certain classes or methods should exist, and looked for these in the API. Jadeite's “placeholders” let users add new “pretend” classes or methods that are displayed in the actual API documentation, and can be annotated with the appropriate APIs to use instead. Since studies showed that programmers had difficulty finding the right classes from long lists in documentation, Jadeite takes advantage of usage statistics to display commonly used classes more prominently. Programmers had difficulty discovering how to instantiate objects, so Jadeite uses a large corpus of sample code to automatically the most common ways to construct an instance of any given class. An evaluation showed that programmers were about three times faster at performing common tasks with Jadeite than with standard Javadoc. </td></tr>
<tr id="bib_Stylos2009Improving" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Stylos2009Improving,
  title={Improving API documentation using API usage information},
  author={Stylos, Jeffrey and Faulring, Andrew and Yang, Zizhuang and Myers, Brad A.},
  booktitle={IEEE Symposium on Visual Languages and Human-Centric Computing},
  pages={119-126},
  year={2009},
 keywords={Java;application program interfaces;document handling;system documentation;API documentation;API usage information;Jadeite;application program interfaces;standard Javadoc;Aggregates},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Jeong2009Improving" class="entry">
<li>S. Y. Jeong, Y. Xie, J. Beaton, B. A. Myers, J. Stylos, R. Ehret, J. Karstens, A. Efeoglu, and D. K. Busse, "Improving documentation for esoa apis through user studies," in End-User Development, International Symposium, Is-Eud 2009, Siegen, Germany, March 2-4, 2009. Proceedings, 2009, pp. 86-105.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Jeong2009Improving','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Jeong2009Improving','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Jeong2009Improving" class="abstract noshow"><td colspan="7"><b>Abstract</b>: All software today is written using libraries, toolkits, frameworks and other application programming interfaces (APIs). We performed a user study of the online documentation a large and complex API f </td></tr>
<tr id="bib_Jeong2009Improving" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Jeong2009Improving,
  title={Improving Documentation for eSOA APIs through User Studies},
  author={Jeong, Sae Young and Xie, Yingyu and Beaton, Jack and Myers, Brad A. and Stylos, Jeff and Ehret, Ralf and Karstens, Jan and Efeoglu, Arkin and Busse, Daniela K.},
  booktitle={End-User Development,  International Symposium, Is-Eud 2009, Siegen, Germany, March 2-4, 2009. Proceedings},
  pages={86-105},
  year={2009},
 keywords={Usability;API Design;Service-Oriented Architecture;Web Services;Documentation;Business Solution Architects},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Stylos2009Jadeite" class="entry">
<li>J. Stylos, B. A. Myers, and Z. Yang, "Jadeite:improving api documentation using usage information," in Proc. CHI, 2009, pp. 4429-4434.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Stylos2009Jadeite','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Stylos2009Jadeite','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Stylos2009Jadeite" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Jadeite is a new Javadoc-like API documentation system that takes advantage of multiple users' aggregate experience to reduce difficulties that programmers have learning new APIs. Previous studies have shown that programmers often guessed that certain classes or methods should exist, and looked for these in the API. Jadeite's "placeholders" let users add new "pretend" classes or methods that are displayed in the actual API documentation, and can be annotated with the appropriate APIs to use instead. Since studies showed that programmers had difficulty finding the right classes from long lists in documentation, Jadeite takes advantage of usage statistics to display commonly used classes more prominently. Programmers had difficulty finding the right helper objects and discovering how to instantiate objects, so Jadeite uses a large corpus of sample code to automatically identify the most common ways to construct an instance of any given class. </td></tr>
<tr id="bib_Stylos2009Jadeite" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Stylos2009Jadeite,
  title={Jadeite:improving API documentation using usage information},
  author={Stylos, Jeffrey and Myers, Brad A. and Yang, Zizhuang},
  booktitle={Proc. CHI},
  pages={4429-4434},
  year={2009},
 keywords={APIs;documentation;javadoc},
}
</pre></td></tr></table><br>


</ol>


<h4><b>(7) <u>Quality Measurement and Improvement:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">




<table id="qstable" class="sortable" border="0">
<tr id="Oumaziz2017Documentation" class="entry">
<li>M. A. Oumaziz, A. Charpentier, J. R. Falleri, and X. Blanc, "Documentation reuse: Hot or not? an empirical study," in International Conference on Software Reuse, 2017, pp. 12-27.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Oumaziz2017Documentation','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Oumaziz2017Documentation','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Oumaziz2017Documentation" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Having available a high quality documentation is critical for software projects. This is why documentation tools such as Javadoc are so popular. As for code, documentation should be reused when possib </td></tr>
<tr id="bib_Oumaziz2017Documentation" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Oumaziz2017Documentation,
  title={Documentation Reuse: Hot or Not? An Empirical Study},
  author={Oumaziz, Mohamed A. and Charpentier, Alan and Falleri, Jean Rémy and Blanc, Xavier},
  booktitle={International Conference on Software Reuse},
  pages={12-27},
  year={2017},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Sohan2017A" class="entry">
<li>S. M. Sohan, F. Maurer, C. Anslow, and M. P. Robillard, "A study of the effectiveness of usage examples in rest api documentation," pp. 53-61, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Sohan2017A','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Sohan2017A','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Sohan2017A" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Generating and maintaining REST API documentation with usage examples can be a time consuming and expensive process for evolving APIs. Most REST API documentation tools focus on automating the documentation of the API objects, but require manual effort for capturing usage examples. Consequently, REST API developers need to know the cost vs. benefit of providing usage examples in the documentation to prioritize the documentation efforts. To this end, we have performed a controlled study with 26 experienced software engineers to understand problems that REST API client developers face while using an API without usage examples. We found that REST API client developers face productivity problems with using correct data types, data formats, required HTTP headers and request body when documentation lacks usage examples. By following the REST API documentation suggestions from this paper, REST API developers can reduce the errors, improve success rate and satisfaction of API client developers.</td></tr>
<tr id="bib_Sohan2017A" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Sohan2017A,
  title={A study of the effectiveness of usage examples in REST API documentation},
  author={Sohan, S M and Maurer, Frank and Anslow, Craig and Robillard, Martin P.},
  pages={53-61},
  year={2017},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Legunsen2016How" class="entry">
<li>O. Legunsen,W. U. Hassan, X. Xu, G. Rou, and D. Marinov, "How good are the specs? a study of the bug-finding effectiveness of existing java api specifications," in Ieee/acm International Conference on Automated Software Engineering, 2016, pp. 602-613.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Legunsen2016How','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Legunsen2016How','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Legunsen2016How" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Runtime verification can be used to find bugs early, during software development, by monitoring test executions against formal specifications (specs). The quality of runtime verification depends on the quality of the specs. While previous research has produced many specs for the Java API, manually or through automatic mining, there has been no large-scale study of their bug-finding effectiveness. We present the first in-depth study of the bug-finding effectiveness of previously proposed specs. We used JavaMOP to monitor 182 manually written and 17 automatically mined specs against more than 18K manually written and 2.1M automatically generated tests in 200 open-source projects. The average runtime overhead was under 4.3x. We inspected 652 violations of manually written specs and (randomly sampled) 200 violations of automatically mined specs. We reported 95 bugs, out of which developers already fixed 74. However, most violations, 82.81% of 652 and 97.89% of 200, were false alarms. Our empirical results show that (1) runtime verification technology has matured enough to incur tolerable runtime overhead during testing, and (2) the existing API specifications can find many bugs that developers are willing to fix; however, (3) the false alarm rates are worrisome and suggest that substantial effort needs to be spent on engineering better specs and properly evaluating their effectiveness. </td></tr>
<tr id="bib_Legunsen2016How" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Legunsen2016How,
  title={How good are the specs? A study of the bug-finding effectiveness of existing Java API specifications},
  author={Legunsen, Owolabi and Hassan, Wajih Ul and Xu, Xinyue and Roşu, Grigore and Marinov, Darko},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={602-613},
  year={2016},
 keywords={empirical study;runtime verification;specification quality},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Uddin2015How" class="entry">
<li>G. Uddin and M. P. Robillard, "How api documentation fails," IEEE Software, vol. 32, no. 4, pp. 68-75, 2015.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Uddin2015How','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Uddin2015How','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Uddin2015How" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Formal documentation can be a crucial resource for learning to how to use an API. However, producing high-quality documentation can be nontrivial. Researchers investigated how 10 common documentation problems manifested themselves in practice. The results are based on two surveys of a total of 323 professional software developers and analysis of 179 API documentation units. The three severest problems were ambiguity, incompleteness, and incorrectness of content. The respondents often mentioned six of the 10 problems as "blockers" </td></tr>
<tr id="bib_Uddin2015How" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Uddin2015How,
  title={How API Documentation Fails},
  author={Uddin, Gias and Robillard, Martin P.},
  journal={IEEE Software},
  volume={32},
  number={4},
  pages={68-75},
  year={2015},
 keywords={software development;API;documentation;user study;software engineering},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Ko2014API" class="entry">
<li>D. Ko, K. Ma, S. Park, S. Kim, D. Kim, and Y. L. Traon, "Api document quality for resolving deprecated apis," vol. 2, no. 1, pp. 27-30, 2014.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Ko2014API','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Ko2014API','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Ko2014API" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Using deprecated APIs often results in security vulnerability or performance degradation. Thus, invocations to deprecated APIs should be immediately replaced by alternative APIs. To resolve deprecated APIs, most developers rely on API documents provided by service API libraries. However, the documents often do not have sufficient information. This makes many deprecated API usages remain unresolved, which leads programs to vulnerable states. This paper reports a result of studying document quality for deprecated APIs. We first collected 260 deprecated APIs of eight Java libraries as well as the corresponding API documents. These documents were manually investigated to figure out whether it provides alternative APIs, rationales, or examples. Then, we examined 2,126 API usages in 249 client applications and figured out whether those were resolved in the subsequent versions. This study revealed that 1) 3.6 APIs was deprecated and 3.6 deprecated APIs are removed from the library a month on average, 2) only 61% of API documents provided alternative APIs while rationale and examples were rarely documented, and 3) 62% of deprecate API usages in client applications were resolved if the corresponding API documents provided alternative APIs while 49% were resolved when the documents provided no alternative APIs. Based on these results, we draw future directions to encourage resolving deprecated APIs. </td></tr>
<tr id="bib_Ko2014API" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Ko2014API,
  title={API Document Quality for Resolving Deprecated APIs},
  author={Ko, D. and Ma, K. and Park, S. and Kim, S. and Kim, D. and Traon, Y. L.},
  volume={2},
  number={1},
  pages={27-30},
  year={2014},
 keywords={application program interfaces;document handling;security of data;software quality;API document quality;Java libraries;alternative API;client applications;resolving deprecated API;security vulnerability},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Kuhn2014Verifiable" class="entry">
<li>T. Kuhn and A. Bergel, "Verifiable source code documentation in controlled natural language," Science of Computer Programming, vol. 96, no. P1, pp. 121-140, 2014.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Kuhn2014Verifiable','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Kuhn2014Verifiable','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Kuhn2014Verifiable" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This paper highlights a deficiency in the way documentation is usually written.•Using controlled natural language is a viable approach.•A prototype as well as its benefits are described. </td></tr>
<tr id="bib_Kuhn2014Verifiable" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Kuhn2014Verifiable,
  title={Verifiable Source Code Documentation in Controlled Natural Language},
  author={Kuhn, Tobias and Bergel, Alexandre},
  journal={Science of Computer Programming},
  volume={96},
  number={P1},
  pages={121-140},
  year={2014},
 keywords={Controlled natural language;Metamodelling;Moose;Pharo},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Watson2013API" class="entry">
<li>R. Watson, M. Stamnes, J. Jeannot-Schroeder, and J. H. Spyridakis, "Api documentation and software community values:a survey of open-source api documentation," in ACM Sigdoc, 2013, pp. 165-174.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Watson2013API','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Watson2013API','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Watson2013API" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Studies of what software developers need from API documentation have reported consistent findings over the years; however, these studies all used similar methods--usually a form of observation or survey. Our study looks at API documentation as artifacts of the open-source software communities who produce them to study how documentation produced by the communities who use the software compares to past studies of what software developers want and need from API documentation. We reviewed API documentation from 33 of the most popular open-source software projects, assessed their documentation elements, and evaluated the quality of their visual design and writing. We found that the documentation we studied included most or all the documentation elements reported as desirable in earlier studies and in the process, we found that the design and writing quality of many documentation sets received considerable attention. Our findings reinforce the API requirements identified in the literature and suggest that the design and writing quality of the documentation are also critical API documentation requirements that warrant further study. </td></tr>
<tr id="bib_Watson2013API" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Watson2013API,
  title={API documentation and software community values:a survey of open-source API documentation},
  author={Watson, Robert and Stamnes, Mark and Jeannot-Schroeder, Jacob and Spyridakis, Jan H.},
  booktitle={ACM Sigdoc},
  pages={165-174},
  year={2013},
 keywords={api;api reference documentation;application programming interface;software documentation;software libraries},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Danielsen2013Validation" class="entry">
<li>P. J. Danielsen and A. Jeffrey, "Validation and interactivity of web api documentation," in IEEE International Conference on Web Services, 2013, pp. 523-530.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Danielsen2013Validation','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Danielsen2013Validation','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Danielsen2013Validation" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Many Web APIs (by which we mean ones using HTTP as the application protocol) do not publish a machine-readable API description (in a language such as WADL or WSDL) but only provide human-readable documentation, usually in HTML. This documentation may be machine-generated, or it may be hand-edited in which case there is the possibility of errors being introduced into the API description. In this paper we present a Web Interface Language (WIfL) vocabulary for API documentation, which is intended to be embedded in HTML using RDFa annotations. We present the semantics of WIfL, including a formal presentation of inheritance and validation. We discuss our WIfL tools, which include a dynamically generated console for interacting with an API's reference implementation, and a validator which can check an API for internal consistency. </td></tr>
<tr id="bib_Danielsen2013Validation" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Danielsen2013Validation,
  title={Validation and Interactivity of Web API Documentation},
  author={Danielsen, Peter J. and Jeffrey, Alan},
  booktitle={IEEE  International Conference on Web Services},
  pages={523-530},
  year={2013},
 keywords={API;Web API;HTTP;Validation;Documentation},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Jiau2012Facing" class="entry">
<li>H. C. Jiau and F. P. Yang, "Facing up to the inequality of crowdsourced API documentation," ACM SIGSOFT Software Engineering Notes, 2012.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Jiau2012Facing','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Jiau2012Facing','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Jiau2012Facing" class="abstract noshow"><td colspan="7"><b>Abstract</b>: API usability is a crucial issue in software development. One bottleneck of API usability is insufficient documentation. This study empirically confirmed the inequality of crowdsourced API documentation, which is one of the main sources of API documentation. To manage the inequality, a method for documentation reuse is proposed based on the nature of object-oriented programming language, inheritance. A case study was conducted in Stackoverflow, which is a widely used Q&#38;A site, to study the feasibility of the documentation reuse. Results of the case study indicate that documentation reuse is feasible in improving both the coverage and quality of crowdsourced API documentations. </td></tr>
<tr id="bib_Jiau2012Facing" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@book{Jiau2012Facing,
  title={Facing up to the inequality of crowdsourced API documentation},
  author={Jiau, Hewijin Christine and Yang, Feng Pu},
  publisher={ACM},
  pages={1-9},
  year={2012},
 keywords={API;GWT;SWT;crowdsourcing;forum;inequality;inheritance;jQuery;power law;stackoverflow},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Watson2012Developing" class="entry">
<li>R.Watson, "Developing best practices for api reference documentation: Creating a platform to study how programmers learn new apis," in Professional Communication Conference, 2012, pp. 1-9.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Watson2012Developing','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Watson2012Developing','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Watson2012Developing" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers use application-programming interface (API) documentation to learn how to use the features of software libraries. How quickly software developers learn to use a library's features determines how quickly they can apply those features in a software application. Recent studies have shown that API documentation is, unfortunately, not always as helpful to software developers as they need it to be. This paper studies the prototype of a tool and a method that are being developed to help technical writers identify the elements of API reference documentation that help software developers complete programming tasks. The tool and method described in this paper use a remote user-assessment platform, which enables researchers and technical writers to study the effect that document design variations have on a large and diverse audience. Such an approach can help technical writers identify new best practices for writing effective API documentation. </td></tr>
<tr id="bib_Watson2012Developing" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Watson2012Developing,
  title={Developing best practices for API reference documentation: Creating a platform to study how programmers learn new APIs},
  author={Watson, R.},
  booktitle={Professional Communication Conference},
  pages={1-9},
  year={2012},
 keywords={technical writing;API documentation;best practices;remote user assessment},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Watson2012Development" class="entry">
<li>R. B. Watson, "Development and application of a heuristic to assess trends in api documentation," in ACM International Conference on Design of Communication, 2012, pp. 295-302.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Watson2012Development','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Watson2012Development','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Watson2012Development" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Computer technology has made amazing advances in the past few decades; however, the software documentation of today still looks strikingly similar to the software documentation used 30 years ago. If this continues into the 21st century, more and more software developers could be using 20th-century-style documentation to solve 21st-century problems with 21st-century technologies. Is 20th-century-style documentation up to the challenge? How can that be measured? This paper seeks to answer those questions by developing a heuristic to identify whether the documentation set for an application programming interface (API) contains the key elements of API reference documentation that help software developers learn an API. The resulting heuristic was tested on a collection of software documentation that was chosen to provide a diverse set of examples with which to validate the heuristic. In the course of testing the heuristic, interesting patterns in the API documentation were observed. For example, twenty-five percent of the documentation sets studied did not have any overview information, which, according to studies, is one of the most basic elements an API documentation set needs to help software developers learn to use the API. The heuristic produced by this research can be used to evaluate large sets of API documentation, track trends in API documentation, and facilitate additional research. </td></tr>
<tr id="bib_Watson2012Development" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Watson2012Development,
  title={Development and application of a heuristic to assess trends in API documentation},
  author={Watson, Robert B.},
  booktitle={ACM International Conference on Design of Communication},
  pages={295-302},
  year={2012},
 keywords={Application programming interface;API;API reference documentation;Software documentation;Software libraries},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Parnin2011Measuring" class="entry">
<li>C. Parnin and C. Treude, "Measuring api documentation on the web," in InternationalWorkshop onWeb 2.0 for Software Engineering, 2011, pp. 25-30.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Parnin2011Measuring','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Parnin2011Measuring','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Parnin2011Measuring" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software development blogs, developer forums and Q&#38;A websites are changing the way software is documented. With these tools, developers can create and communicate knowledge and experiences without relying on a central authority to provide official documentation. Instead, any content created by a developer is just a web search away. To understand whether documentation via social media can replace or augment more traditional forms of documentation, we study the extent to which the methods of one particular API - jQuery - are documented on the Web. We analyze 1,730 search results and show that software development blogs in particular cover 87.9% of the API methods, mainly featuring tutorials and personal experiences about using the methods. Further, this effort is shared by a large group of developers contributing just a few blog posts. Our findings indicate that social media is more than a niche in software documentation, that it can provide high levels of coverage and that it gives readers a chance to engage with authors. </td></tr>
<tr id="bib_Parnin2011Measuring" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Parnin2011Measuring,
  title={Measuring API documentation on the web},
  author={Parnin, Chris and Treude, Christoph},
  booktitle={International Workshop on Web 2.0 for Software Engineering},
  pages={25-30},
  year={2011},
 keywords={api documentation;crowd documentation;social media},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Dubochet2010Improving" class="entry">
<li>G. Dubochet and D. Malayeri, "Improving api documentation for java-like languages," in Evaluation and Usability of Programming Languages and Tools, 2010, pp. 1-1.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Dubochet2010Improving','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Dubochet2010Improving','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Dubochet2010Improving" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The Javadoc paradigm for displaying API documentation to users is quite popular, with similar variants existing for many mainstream languages. However, two user interface design properties of Javadoc may reduce its utility when displaying documentation for APIs that make use of inheritance and parametric polymorphism. First, Javadoc does not show a flattened view of all members of a class or interface, but rather only those defined directly in the type. Second, and as a consequence, any methods whose types contain type parameters of a superclass will always be shown in the context of the superclass. That is, if the method C.m returns type T, subclasses of C will always see this parent signature, even if they instantiate T to a concrete type such as Integer. We show that this situation arises often in some libraries, and present the results of a study that measures the usability consequences of these two Javadoc design decisions. Our results show that a user interface that shows instantiated type parameters for members is preferred over one that presents type parameters in the Javadoc style. </td></tr>
<tr id="bib_Dubochet2010Improving" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Dubochet2010Improving,
  title={Improving API documentation for Java-like languages},
  author={Dubochet, Gilles and Malayeri, Donna},
  booktitle={Evaluation and Usability of Programming Languages and Tools},
  pages={1-1},
  year={2010},
 keywords={documentation;generics;javadoc;scala;scaladoc},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Wilde2008Document" class="entry">
<li>E. Wilde and R. J. Glushko, "Document design matters," Communications of the Acm, vol. 51, no. 10, pp. 43-49, 2008.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Wilde2008Document','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Wilde2008Document','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Wilde2008Document" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The classical approach to the data aspect of system design distinguishes conceptual, logical, and physical models. Models of each type or level are governed by metamodels that specify the kinds of concepts and constraints that can be used by each model; in most cases metamodels are accompanied by languages for describing models. For example, in database design, conceptual models usually conform to the Entity-Relationship (ER) metamodel (or some extension of it), the logical model maps ER models to relational tables and introduces normalization, and the physical model handles implementation issues such as possible denormalizations in the context of a particular database schema language. In this modeling methodology, there is a single hierarchy of models that rests on the assumption that one data model spans all modeling levels and applies to all the applications in some domain. The "one true model" approach assumes homogeneity, but this does not work very well for the Web. The Web as a constantly growing ecosystem of heterogeneous data and services has challenged a number of practices and theories about the design of IT landscapes. Instead of being governed by "one true model" used by everyone, the underlying assumption of top-down design, Web data and services evolve in an uncoordinated fashion. As a result, a fundamental challenge with Web data and services is matching and mapping local and often partial models that not only are different models of the same application domain, but also differ, implicitly or explicitly, in their associated metamodels. </td></tr>
<tr id="bib_Wilde2008Document" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Wilde2008Document,
  title={Document Design Matters},
  author={Wilde, Erik and Glushko, Robert J.},
  journal={Communications of the Acm},
  volume={51},
  number={10},
  pages={43-49},
  year={2008},
 keywords={3D integration;stacking process;design;hardware},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Ratiu2008Evaluating" class="entry">
<li>D. Ratiu and J. Juerjens, "Evaluating the reference and representation of domain concepts in apis," in The IEEE International Conference on Program Comprehension, 2008, pp. 242-247.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Ratiu2008Evaluating','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Ratiu2008Evaluating','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Ratiu2008Evaluating" class="abstract noshow"><td colspan="7"><b>Abstract</b>: As libraries are the most widespread form of software reuse, the usability of their APIs substantially influences the productivity of programmers in all software development phases. In this paper we develop a framework to characterize domain-specific APIs along two directions: 1) how can the API users reference the domain concepts implemented by the API; 2) how are the domain concepts internally represented in the API. We define metrics that allow the API developer for example to assess the conceptual complexity of his API and the non-uniformity and ambiguities introduced by the API </td></tr>
<tr id="bib_Ratiu2008Evaluating" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Ratiu2008Evaluating,
  title={Evaluating the Reference and Representation of Domain Concepts in APIs},
  author={Ratiu, Daniel and Juerjens, Jan},
  booktitle={The  IEEE International Conference on Program Comprehension},
  pages={242-247},
  year={2008},
 keywords={concepts location;design and evaluation of APIs},
}
</pre></td></tr></table><br>



</ol>


<h4><b>(8) <u>Information Embedding and Enhancement:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">


<table id="qstable" class="sortable" border="0">
<tr id="Treude2016Augmenting" class="entry">
<li>C. Treude and M. P. Robillard, "Augmenting api documentation with insights from stack overflow," in Ieee/acm International Conference on Software Engineering, 2016, pp. 392-403.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Treude2016Augmenting','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Treude2016Augmenting','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Treude2016Augmenting" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers need access to different kinds of information which is often dispersed among different documentation sources, such as API documentation or Stack Overflow. We present an approach to automatically augment API documentation with "insight sentences" from Stack Overflow -- sentences that are related to a particular API type and that provide insight not contained in the API documentation of that type. Based on a development set of 1,574 sentences, we compare the performance of two state-of-the-art summarization techniques as well as a pattern-based approach for insight sentence extraction. We then present SISE, a novel machine learning based approach that uses as features the sentences themselves, their formatting, their question, their answer, and their authors as well as part-of-speech tags and the similarity of a sentence to the corresponding API documentation. With SISE, we were able to achieve a precision of 0.64 and a coverage of 0.7 on the development set. In a comparative study with eight software developers, we found that SISE resulted in the highest number of sentences that were considered to add useful information not found in the API documentation. These results indicate that taking into account the meta data available on Stack Overflow as well as part-of-speech tags can significantly improve unsupervised extraction approaches when applied to Stack Overflow data. </td></tr>
<tr id="bib_Treude2016Augmenting" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Treude2016Augmenting,
  title={Augmenting API documentation with insights from stack overflow},
  author={Treude, Christoph and Robillard, Martin P.},
  booktitle={Ieee/acm  International Conference on Software Engineering},
  pages={392-403},
  year={2016},
 keywords={API documentation;insight sentences;stack overflow},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Chen2014Who" class="entry">
<li>C. Chen and K. Zhang, "Who asked what: integrating crowdsourced faqs into api documentation," in Companion Proceedings of the International Conference on Software Engineering, 2014, pp. 456-459.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Chen2014Who','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Chen2014Who','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Chen2014Who" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Documentation is important for learning Application Programming Interfaces (APIs). In addition to official documents, much crowdsourced API knowledge is available on the Web. Crowdsourced API documentation is fragmented, scattered around the Web, and disconnected from official documentation. Developers often rely on Web search to retrieve additional programming help. We propose to connect these two types of documentation by capturing developers' Web browsing behavior in the context of document reading and integrating crowdsourced frequently asked questions (FAQs) into API documents. Such an integration not only provides relevant API help more conveniently, but also opens a new approach to promoting knowledge collaboration and studying API users' information needs. </td></tr>
<tr id="bib_Chen2014Who" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Chen2014Who,
  title={Who asked what: integrating crowdsourced FAQs into API documentation},
  author={Chen, Cong and Zhang, Kang},
  booktitle={Companion Proceedings of the  International Conference on Software Engineering},
  pages={456-459},
  year={2014},
 keywords={API;crowdsourcing;documentation;search;social media},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Kim2013Enriching" class="entry">
<li>J. Kim, S. Lee, S. W. Hwang, and S. Kim, "Enriching documents with examples:a corpus mining approach," Acm Transactions on Information Systems, vol. 31, no. 1, pp. 1-27, 2013.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Kim2013Enriching','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Kim2013Enriching','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Kim2013Enriching" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software developers increasingly rely on information from the Web, such as documents or code examples on application programming interfaces (APIs), to facilitate their development processes. However, API documents often do not include enough information for developers to fully understand how to use the APIs, and searching for good code examples requires considerable effort. To address this problem, we propose a novel code example recommendation system that combines the strength of browsing documents and searching for code examples and returns API documents embedded with high-quality code example summaries mined from the Web. Our evaluation results show that our approach provides code examples with high precision and boosts programmer productivity. </td></tr>
<tr id="bib_Kim2013Enriching" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@article{Kim2013Enriching,
  title={Enriching Documents with Examples:A Corpus Mining Approach},
  author={Kim, Jinhan and Lee, Sanghoon and Hwang, Seung Won and Kim, Sunghun},
  journal={Acm Transactions on Information Systems},
  volume={31},
  number={1},
  pages={1-27},
  year={2013},
 keywords={API document;Clustering;code search;ranking},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Montandon2013Documenting" class="entry">
<li>J. E. Montandon, H. Borges, D. Felix, and M. T. Valente, "Documenting apis with examples: Lessons learned with the apiminer platform," in Reverse Engineering, 2013, pp. 401-408.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Montandon2013Documenting','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Montandon2013Documenting','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Montandon2013Documenting" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Software development increasingly relies on Application Programming Interfaces (APIs) to increase productivity. However, learning how to use new APIs in many cases is a nontrivial task given their ever-increasing complexity. To help developers during the API learning process, we describe in this paper a platform - called APIMiner - that instruments the standard Java-based API documentation format with concrete examples of usage. The examples are extracted from a private source code repository - composed by real systems - and summarized using a static slicing algorithm. We also describe a particular instantiation of our platform for the Android API. To evaluate the proposed solution, we performed a field study, when professional Android developers used the platform by four months. </td></tr>
<tr id="bib_Montandon2013Documenting" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Montandon2013Documenting,
  title={Documenting APIs with examples: Lessons learned with the APIMiner platform},
  author={Montandon, Joao Eduardo and Borges, Hudson and Felix, Daniel and Valente, Marco Tulio},
  booktitle={Reverse Engineering},
  pages={401-408},
  year={2013},
 keywords={field study;API documentation;source code examples;JavaDoc},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Mar2012Recommending" class="entry">
<li>L. W. Mar, Y. C. Wu, and H. C. Jiau, "Recommending proper api code examples for documentation purpose," in Software Engineering Conference, 2012, pp. 331-338.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Mar2012Recommending','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Mar2012Recommending','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Mar2012Recommending" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Code examples are important resources for expressing correct application programming interface (API) usages. However, many framework and library APIs fail in offering sufficient code examples in corresponding API documentations. This is because constructing proper code examples for documentation purpose takes significant developers' efforts. To reduce such effort, this work proposes a methodology, PropER-Doc, that recommends proper code examples for documentation purpose. PropER-Doc accepts queries from API developers and utilizes code search engines (CSEs) to collect corresponding code example candidates. The structural and conceptual links between API elements are captured from the API implementation and available API documents to guide candidate recommendation. During recommendation, PropER-Doc groups collected candidates based on involved API types for distinguishing different API usages. To assist API developers in selecting proper candidates, a diagrammatic presentation and three code example appropriateness metrics are also developed in {PropER-Doc}. Two case studies on Eclipse JDT framework are conducted to confirm the effectiveness of PropER-Doc. </td></tr>
<tr id="bib_Mar2012Recommending" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Mar2012Recommending,
  title={Recommending Proper API Code Examples for Documentation Purpose},
  author={Mar, Lee Wei and Wu, Ye Chi and Jiau, Hewijin Christine},
  booktitle={Software Engineering Conference},
  pages={331-338},
  year={2012},
 keywords={code example;framework;documentation;API usage},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Kim2010Adding" class="entry">
<li>J. Kim, S. Lee, S. W. Hwang, and S. Kim, "Adding examples into java documents," in Ieee/acm International Conference on Automated Software Engineering, 2010, pp. 540-544.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Kim2010Adding','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Kim2010Adding','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Kim2010Adding" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Code examples play an important role to explain the usage of Application Programming Interfaces (APIs), but most API documents do not provide sufficient code examples. For example, for the JDK 5 documents (JavaDocs), only 2% of APIs have code examples. In this paper, we propose a technique that automatically augments API documents with code examples. Our approach finds and embeds code examples for more than 75% of the APIs in JavaDocs 5. </td></tr>
<tr id="bib_Kim2010Adding" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Kim2010Adding,
  title={Adding Examples into Java Documents},
  author={Kim, Jinhan and Lee, Sanghoon and Hwang, Seung Won and Kim, Sunghun},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={540-544},
  year={2010},
 keywords={Ranking;API Documents;Examples;Structures;Code Clustering},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Hoffman2003API" class="entry">
<li>D. Hoffman and P. Strooper, API documentation with executable examples. Elsevier Science Inc., 2003.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Hoffman2003API','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Hoffman2003API','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Hoffman2003API" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The rise of component-based software development has created an urgent need for effective application program interface (API) documentation. Experience has shown that it is hard to create precise and readable documentation. Prose documentation can provide a good overview but lacks precision. Formal methods offer precision but the resulting documentation is expensive to develop. Worse, few developers have the skill or inclination to read formal documentation. We present a pragmatic solution to the problem of API documentation. We augment the prose documentation with executable test cases, including expected outputs, and use the prose plus the test cases as the documentation. With appropriate tool support, the test cases are easy to develop and read. Such test cases constitute a completely formal, albeit partial, specification of input/output behavior. Equally important, consistency between code and documentation is demonstrated by running the test cases. This approach provides an attractive bridge between formal and informal documentation. We also present a tool that supports compact and readable test cases, and generation of test drivers and documentation, and illustrate the approach with detailed case studies. </td></tr>
<tr id="bib_Hoffman2003API" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@book{Hoffman2003API,
  title={API documentation with executable examples},
  author={Hoffman, Daniel and Strooper, Paul},
  publisher={Elsevier Science Inc.},
  pages={143-156},
  year={2003},
 keywords={Computer Science, Software Engineering;Computer Science, Theory & Methods;Formal Specification},
}
</pre></td></tr></table><br>

</ol>


<h4><b>(9) <u>Error Detection:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">




<table id="qstable" class="sortable" border="0">
<tr id="Gall2017Analyzing" class="entry">
<li>Y. Zhou; R.Gu; T. Chen; Z. Huang; S. Panichella; H. Gall, "Analyzing apis documentation and code to detect directive defects," in Ieee/acm International Conference on Software Engineering, 2017, pp. 27-37.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Gall2017Analyzing','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Gall2017Analyzing','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Gall2017Analyzing" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Application Programming Interface (API) documents represent one of the most important references for API users. However, it is frequently reported that the documentation is inconsistent with the source code and deviates from the API itself. Such inconsistencies in the documents inevitably confuse the API users hampering considerably their API comprehension and the quality of software built from such APIs. In this paper, we propose an automated approach to detect defects of API documents by leveraging techniques from program comprehension and natural language processing. Particularly, we focus on the directives of the API documents which are related to parameter constraints and exception throwing declarations. A first-order logic based constraint solver is employed to detect such defects based on the obtained analysis results. We evaluate our approach on parts of well documented JDK 1.8 APIs. Experiment results show that, out of around 2000 API usage constraints, our approach can detect 1158 defective document directives, with a precision rate of 81.6%, and a recall rate of 82.0%, which demonstrates its practical feasibility. </td></tr>
<tr id="bib_Gall2017Analyzing" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Gall2017Analyzing,
  title={Analyzing APIs documentation and code to detect directive defects},
  author={Gall, Harald and Gall, Harald and Gall, Harald and Gall, Harald and Gall, Harald and Gall, Harald},
  booktitle={Ieee/acm  International Conference on Software Engineering},
  pages={27-37},
  year={2017},
 keywords={API documentation;static analysis;natural language processing},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Murali2017Bayesian" class="entry">
<li>V. Murali, S. Chaudhuri, and C. Jermaine, "Bayesian specification learning for finding api usage errors," in Joint Meeting on Foundations of Software Engineering, 2017, pp. 151-162.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Murali2017Bayesian','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Murali2017Bayesian','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Murali2017Bayesian" class="abstract noshow"><td colspan="7"><b>Abstract</b>: 

We present a Bayesian framework for learning probabilistic specifications from large, unstructured code corpora, and then using these specifications to statically detect anomalous, hence likely buggy, program behavior. Our key insight is to build a statistical model that correlates all specifications hidden inside a corpus with the syntax and observed behavior of programs that implement these specifications. During the analysis of a particular program, this model is conditioned into a posterior distribution that prioritizes specifications that are relevant to the program. The problem of finding anomalies is now framed quantitatively, as a problem of computing a distance between a "reference distribution" over program behaviors that our model expects from the program, and the distribution over behaviors that the program actually produces.

We implement our ideas in a system, called Salento, for finding anomalous API usage in Android programs. Salento learns specifications using a combination of a topic model and a neural network model. Our encouraging experimental results show that the system can automatically discover subtle errors in Android applications in the wild, and has high precision and recall compared to competing probabilistic approaches.
</td></tr>
<tr id="bib_Murali2017Bayesian" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Murali2017Bayesian,
  title={Bayesian specification learning for finding API usage errors},
  author={Murali, Vijayaraghavan and Chaudhuri, Swarat and Jermaine, Chris},
  booktitle={Joint Meeting on Foundations of Software Engineering},
  pages={151-162},
  year={2017},
 keywords={APIs;Anomaly Detection;Bug Finding;Specification Learning},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Gyori2016NonDex" class="entry">
<li>A. Gyori, B. Lambeth, A. Shi, O. Legunsen, and D. Marinov, "Nondex: a tool for detecting and debugging wrong assumptions on java api specifications," in ACM Sigsoft International Symposium on Foundations of Software Engineering, 2016, pp. 993-997.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Gyori2016NonDex','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Gyori2016NonDex','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Gyori2016NonDex" class="abstract noshow"><td colspan="7"><b>Abstract</b>: We present NonDex, a tool for detecting and debugging wrong assumptions on Java APIs. Some APIs have underdetermined specifications to allow implementations to achieve different goals, e.g., to optimize performance. When clients of such APIs assume stronger-than-specified guarantees, the resulting client code can fail. For example, HashSet鈥檚 iteration order is underdetermined, and code assuming some implementation-specific iteration order can fail. NonDex helps to proactively detect and debug such wrong assumptions. NonDex performs detection by randomly exploring different behaviors of underdetermined APIs during test execution. When a test fails during exploration, NonDex searches for the invocation instance of the API that caused the failure. NonDex is open source, well-integrated with Maven, and also runs from the command line. During our experiments with the NonDex Maven plugin, we detected 21 new bugs in eight Java projects from GitHub, and, using the debugging feature of NonDex, we identified the underlying wrong assumptions for these 21 new bugs and 54 previously detected bugs. We opened 13 pull requests; developers already accepted 12, and one project changed the continuous-integration configuration to run NonDex on every push. The demo video is at: https://youtu.be/h3a9ONkC59c </td></tr>
<tr id="bib_Gyori2016NonDex" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Gyori2016NonDex,
  title={NonDex: a tool for detecting and debugging wrong assumptions on Java API specifications},
  author={Gyori, Alex and Lambeth, Ben and Shi, August and Legunsen, Owolabi and Marinov, Darko},
  booktitle={ACM Sigsoft International Symposium on Foundations of Software Engineering},
  pages={993-997},
  year={2016},
 keywords={NonDex;flaky tests;underdetermined API},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Yuan2016APEx" class="entry">
<li>K. Yuan, B. Ray, and S. Jana, "Apex: Automated inference of error specifications for c apis," in Ieee/acm International Conference on Automated Software Engineering, 2016, pp. 472-482.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Yuan2016APEx','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Yuan2016APEx','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Yuan2016APEx" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Although correct error handling is crucial to software robustness and security, developers often inadvertently introduce bugs in error handling code. Moreover, such bugs are hard to detect using existing bug-finding tools without correct error specifications. Creating error specifications manually is tedious and error-prone. In this paper, we present a new technique that automatically infers error specifications of API functions based on their usage patterns in C programs. Our key insight is that error-handling code tend to have fewer branching points and program statements than the code implementing regular functionality. Our scheme leverages this property to automatically identify error handling code at API call sites and infer the corresponding error constraints. We then use the error constraints from multiple call sites for robust inference of API error specifications. We evaluated our technique on 217 API functions from 6 different libraries across 28 projects written in C and found that it can identify error-handling paths with an average precision of 94% and recall of 66%. We also found that our technique can infer correct API error specifications with an average precision of 77% and recall of 47%. To further demonstrate the usefulness of the inferred error specifications, we used them to find 118 previously unknown potential bugs (including several security flaws that are currently being fixed by the corresponding developers) in the 28 tested projects. </td></tr>
<tr id="bib_Yuan2016APEx" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Yuan2016APEx,
  title={APEx: Automated inference of error specifications for C APIs},
  author={Yuan, Kang and Ray, Baishakhi and Jana, Suman},
  booktitle={Ieee/acm International Conference on Automated Software Engineering},
  pages={472-482},
  year={2016},
 keywords={API errors;error handling bugs;specification mining},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Zhong2013Detecting" class="entry">
<li>H. Zhong and Z. Su, "Detecting api documentation errors," in ACM Sigplan International Conference on Object Oriented Programming Systems Languages & Applications, 2013, pp. 803-816.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Zhong2013Detecting','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Zhong2013Detecting','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Zhong2013Detecting" class="abstract noshow"><td colspan="7"><b>Abstract</b>: When programmers encounter an unfamiliar API library, they often need to refer to its documentations, tutorials, or discussions on development forums to learn its proper usage. These API documents contain valuable information, but may also mislead programmers as they may contain errors (e.g., broken code names and obsolete code samples). Although most API documents are actively maintained and updated, studies show that many new and latent errors do exist. It is tedious and error-prone to find such errors manually as API documents can be enormous with thousands of pages. Existing tools are ineffective in locating documentation errors because traditional natural language (NL) tools do not understand code names and code samples, and traditional code analysis tools do not understand NL sentences. In this paper, we propose the first approach, DOCREF, specifically designed and developed to detect API documentation errors. We formulate a class of inconsistencies to indicate potential documentation errors, and combine NL and code analysis techniques to detect and report such inconsistencies. We have implemented DOCREF and evaluated its effectiveness on the latest documentations of five widely-used API libraries. DOCREF has detected more than 1,000 new documentation errors, which we have reported to the authors. Many of the errors have already been confirmed and fixed, after we reported them. </td></tr>
<tr id="bib_Zhong2013Detecting" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Zhong2013Detecting,
  title={Detecting API documentation errors},
  author={Zhong, Hao and Su, Zhendong},
  booktitle={ACM Sigplan International Conference on Object Oriented Programming Systems Languages & Applications},
  pages={803-816},
  year={2013},
 keywords={api documentation error;outdated documentation},
}
</pre></td></tr></table><br>


</ol>


<h4><b>(10) <u>Evolution:</u></b></h4>
		<br>
<ol class="paper-list" id="grants">




<table id="qstable" class="sortable" border="0">
<tr id="Mattson2017GraphBLAS" class="entry">
<li>T. G. Mattson, C. Yang, S. Mcmillan, A. Bulu, and J. E. Moreira, "Graphblas c api: Ideas for future versions of the specification," in IEEE High PERFORMANCE Extreme Computing Conference, 2017.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Mattson2017GraphBLAS','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Mattson2017GraphBLAS','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Mattson2017GraphBLAS" class="abstract noshow"><td colspan="7"><b>Abstract</b>: The GraphBLAS C specification provisional release 1.0 is complete. To manage the scope of the project, we had to defer important functionality to a future version of the specification.  For example, we are well aware that many algorithms benefit from an inspector-executor execution strategy.  We also know that users would benefit from a number of standard predefined semirings as well as more general user-defined types. These and other features are described in this paper in the context of a future release of the GraphBLAS C API. </td></tr>
<tr id="bib_Mattson2017GraphBLAS" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Mattson2017GraphBLAS,
  title={GraphBLAS C API: Ideas for future versions of the specification},
  author={Mattson, Timothy G and Yang, Carl and Mcmillan, Scott and Buluç, Aydın and Moreira, José E},
  booktitle={IEEE High PERFORMANCE Extreme Computing Conference},
  year={2017},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Subramanian2014Live" class="entry">
<li>S. Subramanian, L. Inozemtseva, and R. Holmes, "Live api documentation," in Proceedings of the 36th International Conference on Software Engineering, 2014, pp. 643-652.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Subramanian2014Live','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Subramanian2014Live','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Subramanian2014Live" class="abstract noshow"><td colspan="7"><b>Abstract</b>: Application Programming Interfaces (APIs) provide powerful abstraction mechanisms that enable complex functionality to be used by client programs. However, this abstraction does not come for free: understanding how to use an API can be difficult. While API documentation can help, it is often insufficient on its own. Online sites like Stack Overflow and Github Gists have grown to fill the gap between traditional API documentation and more example-based resources. Unfortunately, these two important classes of documentation are independent.This thesis describes an iterative, deductive method of linking source code examplesto API documentation. We also present an implementation of this method, called Baker, that is highly precise (0.97) and supports both Java and JavaScript. Baker can be used toenhance traditional API documentation with up-to-date source code examples; it can alsobe used to incorporate links to the API documentation into the code snippets that use theAPI. </td></tr>
<tr id="bib_Subramanian2014Live" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Subramanian2014Live,
  title={Live API documentation},
  author={Subramanian, Siddharth and Inozemtseva, Laura and Holmes, Reid},
  booktitle={Proceedings of the 36th International Conference on Software Engineering},
  pages={643-652},
  year={2014},
 keywords={Source code examples;documentation;source code search},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Watson2014Applying" class="entry">
<li>R. Watson, "Applying the cognitive dimensions of api usability to improve api documentation planning," in Acm International Conference on the Design of Communication Cd-rom, 2014, pp. 1-2.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Watson2014Applying','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Watson2014Applying','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Watson2014Applying" class="abstract noshow"><td colspan="7"><b>Abstract</b>: This interactive poster explores the application of the 12 cognitive dimensions of API usability to API documentation planning by using the dimensions to identify and characterize the factors that influence the documentation that the users of an API require. Many factors can complicate estimating and planning the documentation an API requires. Even when an API's documentation requirements can be estimated, it can be difficult to present to stakeholders an objective basis for the estimate. The cognitive dimensions of API usability have characterized APIs and their users successfully and they have been used to communicate these characterizations to stakeholders. It follows that the same dimensions could also help identify the documentation that an API requires to provide a satisfactory and successful experience for the software developers who use the API. </td></tr>
<tr id="bib_Watson2014Applying" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Watson2014Applying,
  title={Applying the Cognitive Dimensions of API Usability to Improve API Documentation Planning},
  author={Watson, Robert},
  booktitle={Acm International Conference on the Design of Communication Cd-rom},
  pages={1-2},
  year={2014},
 keywords={API;API reference documentation;Application programming interface;Software documentation;Software libraries},
}
</pre></td></tr></table><br>
<table id="qstable" class="sortable" border="0">
<tr id="Shi2011An" class="entry">
<li>L. Shi, H. Zhong, T. Xie, and M. Li, "An empirical study on evolution of api documentation," in International Conference on Fundamental Approaches To Software Engineering, 2011, pp. 416- 431.</li>
<p class="infolinks">[<a href="javascript:toggleInfo('Shi2011An','abstract')">Abstract</a>]  [<a href="javascript:toggleInfo('Shi2011An','bibtex')">BibTeX</a>]  [<a href="http://dx.doi.org/10.1109/TSE.2017.2663435">DOI</a>]  </p></tr>
<tr id="abs_Shi2011An" class="abstract noshow"><td colspan="7"><b>Abstract</b>: With the evolution of an API library, its documentation also evolves. The evolution of API documentation is common knowledge for programmers and library developers, but not in a quantitative form. Wit </td></tr>
<tr id="bib_Shi2011An" class="bibtex noshow"><td colspan="7"><b>BibTeX</b>:
<pre>
@inproceedings{Shi2011An,
  title={An empirical study on evolution of API documentation},
  author={Shi, Lin and Zhong, Hao and Xie, Tao and Li, Mingshu},
  booktitle={International Conference on Fundamental Approaches To Software Engineering},
  pages={416-431},
  year={2011},
}
</pre></td></tr></table><br>

			
			
			
			
			</ol>
			
			
			
			
			
			
			
			
			
			</div>
		</div>
	</div>
</div>
			
			<footer class="footer">
	<div class="container">
		<p class="text-muted"><a href="http://oscar-lab.org/people/~jxzhang/index.htm">Jingxuan Zhang</a>, Ph.D. Candidate at School of Software, Dalian University of Technology, Dalian, Liaoning, China </p>
	</div>
	<div class="color_wrapper"></div>
</footer>
			
			</body>
</html>
